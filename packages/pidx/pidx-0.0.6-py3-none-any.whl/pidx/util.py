# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_util.ipynb.

# %% auto 0
__all__ = ['DataFrameLike', 'DataFrameLikeQ', 'wrapidx', 'detdf', 'dfds', 'getdfidx', 'getdfloc', 'getdfiloc', 'getdficat',
           'mergebools', 'idxisin', 'safeidx', 'safeloc', 'safeiloc']

# %% ../nbs/02_util.ipynb 6
#| export


# %% ../nbs/02_util.ipynb 8
from typing import Union, Tuple, TypeAlias, Optional

# %% ../nbs/02_util.ipynb 11
#| export

# %% ../nbs/02_util.ipynb 13
try: import numpy as np, pandas as pd
except ImportError: ...

# %% ../nbs/02_util.ipynb 15
#| export


# %% ../nbs/02_util.ipynb 17
#| export


# %% ../nbs/02_util.ipynb 19
from atyp import DataFrame, Dataset, DataFrameQ, DatasetQ, IndexQ, IndexLike, IndexLikeQ
from chck import isidxlike, istuple, isdfds, isdf
from atup import argtup
from getr import getdf, getindex as index, getloc as loc, getiloc as iloc, geticat as icat
from fpos import arg1st
from atyp import DataFrameQ, DatasetQ, IterBool, NPArray
from chck import isboolidx, isiter
from atyp import (DataFrameQ, DatasetQ, IndexQ, IndexLikeQ, )
from chck import isnone, isidxlike

# from itry import pddataframe, ptdataset

# %% ../nbs/02_util.ipynb 21
from .mock import dummydf

# %% ../nbs/02_util.ipynb 25
DataFrameLike: TypeAlias = Union[Dataset, DataFrame]
DataFrameLikeQ: TypeAlias = Optional[DataFrameLike]
# DataFrameLikes: TypeAlias = Tuple[Union[Dataset, DataFrame, DataFrameLike], ...]

# %% ../nbs/02_util.ipynb 26
def wrapidx(idx: IndexLikeQ = None) -> IndexLike:
    '''Wrap idx in a tuple if it's not already a tuple or an index-like object'''
    idxlen = len(argtup(idx))
    if idxlen == 1 and not (isidxlike(idx) or istuple(idx)):
        idx = list((idx, ))
    return idx

# %% ../nbs/02_util.ipynb 27
def detdf(*args: DataFrameLike) -> DataFrameQ:
    '''
    Determine the df from any of the args if the current `arg` is a `df` or `ds.df`

    `dfds` searches for the first pandas DataFrame found in any of the `args` or `arg.df` 
    (if and only if `arg` is a pytorch `Dataset`) and returns it

    Notes
    -----
    df : `pd.DataFrame`
    ds : `torch.utils.data.dataset.Dataset`
    '''
    arg = arg1st(*args, flag=lambda e: isdf(e) or isdfds(e), default=None)        
    return getdf(arg)

def dfds(df: DataFrameQ = None, ds: DatasetQ = None, *args: DataFrameLike) -> DataFrameQ:
    '''Get the `df` from either `df` or `ds.df` where `df`'''        
    return detdf(df, ds, *args)

# %% ../nbs/02_util.ipynb 28
def getdfidx(dl: DataFrameLike = None, *args: DataFrameLike) -> IndexQ:
    '''Get the df's index from either `df` or `ds.df`'''
    return index(dfds(dl, *args))

def getdfloc(dl: DataFrameLike, *args: DataFrameLike) -> IndexQ:
    '''Get the df's `LocIndexer` from either `df` or `ds.df`'''
    return loc(detdf(dl, *args))

def getdfiloc(dl: DataFrameLike, *args: DataFrameLike) -> IndexQ:
    '''Get the df's `iLocIndexer` from either `df` or `ds.df`'''
    return iloc(detdf(dl, *args))

def getdficat(dl: DataFrameLike, *args: DataFrameLike) -> IndexQ:
    '''Get the df's `iLocIndexer` from either `df` or `ds.df`'''
    return icat(detdf(dl, *args))

# %% ../nbs/02_util.ipynb 29
def mergebools(idx: IterBool, dl: DataFrameLike = None, *args: DataFrameLike) -> NPArray:
    '''Merge boolean indexes.'''
    if not isiter(idx): return np.zeros_like(getdfidx(dl, *args), dtype=bool)
    elif isboolidx(idx): return np.logical_or.reduce(np.vstack(idx))
    return np.logical_or.reduce(idx)

# %% ../nbs/02_util.ipynb 31
def idxisin(idx: IndexLikeQ = None, dl: DataFrameLike = None, *args: DataFrameLike, vals: IndexLikeQ = None) -> IndexLike:
    '''Filter vals for those in df's index'''
    idx = wrapidx(idx)
    if vals is None: vals = getdfidx(dl, *args)
    return type(idx)(list(filter(lambda x: x in vals, idx)))

# %% ../nbs/02_util.ipynb 33
def safeidx(idx: IndexLikeQ = None, dl: DataFrameLike = None, *args: DataFrameLike) -> IndexQ:
    '''Check that idx exists or get the df's index from either `df` or `ds.df`'''
    if isnone(idx) or not isidxlike(idx): return getdfidx(dl, *args)
    return idx

def safeloc(idx: IndexLikeQ = None, dl: DataFrameLike = None, *args: DataFrameLike) -> IndexQ:
    '''Check that idx exists then apply it to the `LocIndexer` from either `df` or `ds.df`'''
    idx = safeidx(idx, dl, *args) if isnone(idx) else idx
    return getdfloc(dl, *args)[idx]

def safeiloc(idx: IndexLikeQ = None, dl: DataFrameLike = None, *args: DataFrameLike) -> IndexQ:
    '''Check that idx exists then apply it to the `iLocIndexer` from either `df` or `ds.df`'''
    idx = safeidx(idx, dl, *args) if isnone(idx) else idx
    return getdfiloc(dl, *args)[idx]

# %% ../nbs/02_util.ipynb 35
#| export
