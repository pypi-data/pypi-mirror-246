Index: src/PyConSolv/ConfGen.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import shutil\nimport os\nfrom tkinter import *\nimport numpy as np\n\nfrom .interfaces.mdengines import MDEngine\nfrom .misc.counterion import Counterion\nfrom .misc.counterionGen import counterionParametrizer\nfrom .misc.frcmod import frcmodParser\nfrom .misc.ions import ionlib\nfrom .misc.mol2 import mol2Parser\nfrom .misc.parameterChecker import ParameterChecker\nfrom .utils.charge import ChargeChanger\nfrom .misc.solvenGen import solventParametrizer\nfrom .misc.solvent import Solvent\nfrom .utils.colorgen import Color\nfrom .interfaces.amber import amberInterface\nfrom .interfaces.calculate import Calculation\nfrom .misc.filestructure import Setup\nfrom .misc.inputparser import XYZ\nfrom .interfaces.multiWFN import MultiWfnInterface\nfrom .misc.outgen import Faker\nfrom .misc.ui import GUI\nfrom .misc.restart import RestartFile\nfrom .utils.copier import Copier\n\n\ndef printlog(message, file):\n    print(message)\n    f = open(file)\n    f.write(message)\n    f.close()\n\n\ndef error(step):\n    \"\"\"\n    Print out an error message\n\n    Parameters:\n        - step: step at which the error happened\n\n    Class variables:\n    \"\"\"\n\n    print(Color.RED + 'Something went wrong, please check your input/output' + Color.END)\n    print(Color.RED + '''\n    ############################################\n    ######             WARNING            ######\n    ######      Calculation failed at:    ######\n    ######{:^32}######\n    ############################################\n    '''.format(step) + Color.END)\n\n\nclass PyConSolv:\n    \"\"\"\n    Run conformer generation in explicit solvent via MD simulations. This package relies on\n    Ambertools(MCPB.py/antechamber/tleap), ORCA 5 and Multiwfn 3.8\n\n    Parameters:\n        - path: location of XYZ file\n\n    Class variables:\n        - self.engine - MD engine to be used for the equilibration and simulation\n        - self.MDEngine - MD engine instance\n        - self.parameterChecker - instance of frcmod parameter error checker\n        - self.version - program version\n        - self.hasMetal - True when a metal is part of the structure, False otherwise\n        - self.restarter - object for reading restart files (see restart.py)\n        - self.inputpath - full path to the folder where the input.xyz file is located\n        - self.path - full path to the input.xyz file is located\n        - self.status - variable used for error checking. 0 means error, 1 means all is well\n        - self.restart - variable used to check the restart point\n        - self.db_file - location of the atom-radius.txt file which contains ionic radius information\n        - self.db_metal_file - location of the atom-radius.txt file which contains ionic radius information for metals\n        - self.amber - Object containing an amberInterface (see amber.py)\n        - self.MCPB - full path to the MCPB_setup folder\n        - self.xyz - Object containing an XYZ (see inputparser.py)\n        - self.solventsImplemented - list of supported solvents\n        - self.refrac - refractive index of custom solvent\n        - self.epsilon - permittivity of custom solvent\n        - self.addSolvent - if true, the optimized and parametrized custom solvent will be stored\n        - self.solventAbb - abbreviation for new solvent\n        - self.solventParamPath - path to location of solvent XYZ file\n        - self.solventPath - path to pre-parametrized solvents\n        - self.counterIon - counterion to be used\n        - self.counterIonsImplemented - list of supported counterions\n    \"\"\"\n\n    def __init__(self, path):\n        self.engine = None\n        self.MDEngine = None\n        self.parameterChecker = None\n        path = os.path.abspath(path)\n        self.counterIon = ''\n        self.refrac = None\n        self.epsilon = None\n        self.solventParamPath = None\n        self.version = '1.0.3.1'\n        self.metals = ['LI', 'BE', 'NA', 'MG', 'AL', 'SI', 'K', 'CA', 'SC', 'TI', 'V', 'CR', 'MN', 'FE',\n                       'CO', 'NI', 'CU', 'ZN',\n                       'GA', 'GE', 'AS', 'SE', 'BR', 'RB', 'SR', 'Y', 'ZR', 'NB', 'MO', 'TC', 'RU', 'RH', 'PD', 'AG',\n                       'CD', 'IN', 'SN', 'SB',\n                       'TE', 'CS', 'BA', 'LA', 'CE', 'PR', 'ND', 'PM', 'SM', 'EU', 'GD', 'TB', 'DY', 'HO', 'ER',\n                       'TM', 'YB', 'YB', 'LU', 'HF',\n                       'TA', 'W', 'RE', 'OS', 'IR', 'PT', 'AU', 'HG', 'TL', 'PB', 'BI', 'PO', 'AT', 'FR', 'RA', 'AC',\n                       'TH', 'PA', 'U', 'NP',\n                       'PU', 'AM', 'CM', 'BK', 'CF', 'ES', 'FM', 'MD', 'NO',\n                       'LR']\n        self.hasMetal = None\n        self.restarter = None\n        self.path = path\n        self.inputFile = path.split('/')[-1]\n        self.inputpath = '/'.join(path.split('/')[:-1])\n        if self.inputFile != 'input.xyz':\n            print('Copying {} to input.xyz\\n'.format(self.inputFile))\n            shutil.copyfile(self.path,self.inputpath + '/input.xyz')\n            self.inputFile = 'input.xyz'\n        if '.xyz' not in self.inputFile:\n            error('Initialization... make sure the input is an xyz file')\n        self.status = 0\n        self.restart = 0\n        self.db_file = os.path.split(__file__)[0] + '/db/atom-radius.txt'\n        self.db_metal_file = os.path.split(__file__)[0] + '/db/metal-radius.txt'\n        self.solventPath = os.path.split(__file__)[0] + '/solvents/'\n        self.ionPath = os.path.split(__file__)[0] + '/counterions/'\n        self.amber = None\n        self.MCPB = self.inputpath + '/MCPB_setup'\n        self.xyz = None\n        ions = ionlib()\n        amberions = list(ions.ionsinAmber.keys())\n        self.counterIonsImplemented = amberions +['OTf-','BF4-', 'BARF-', 'PFC-', 'ScF6-', 'ClO4-', 'BPh4-', 'custom']\n        self.solventsImplemented = ['Water', 'WaterOPC', 'WaterTIP4PEW','Acetonitrile', 'Acetone', 'Benzene', 'Cyclohexane', 'Chloroform', 'CCl4',\n                                    'CH2Cl2', 'DMF', 'DMSO', 'Ethanol', 'Hexane', 'Methanol', 'Ammonia', 'Octanol',\n                                    'THF', 'Toluene', 'custom']\n        self.watermodels = ['Water', 'WaterOPC', 'WaterTIP4PEW']\n        self.metalCheck()\n        self.addSolvent = False\n        self.solventAbb = ''\n        self.boxsize = 20\n\n\n        print(Color.BLUE + r'''\n\n          _____        _____             _____       _       \n         |  __ \\      / ____|           / ____|     | |      \n         | |__) |   _| |     ___  _ __ | (___   ___ | |_   __\n         |  ___/ | | | |    / _ \\| '_ \\ \\___ \\ / _ \\| \\ \\ / /\n         | |   | |_| | |___| (_) | | | |____) | (_) | |\\ V / \n         |_|    \\__, |\\_____\\___/|_| |_|_____/ \\___/|_| \\_/  \n                 __/ |                                       \n                |___/                                        \n                                Ver {}\n                    \nWelcome to PyConSolv, your friendly neighbourhood conformer generator\n\nCalculations will be set up in:\n\n{}\n\n        '''.format(self.version, self.inputpath) + Color.END)\n\n    def checkRestart(self):\n        \"\"\"\n        Check for the existence of a restart file (pyconsolv.restart) and get last completed step\n\n        Parameters:\n\n        Class variables:\n            - self.restarter - RestartFile object used for checking and writing restart file (see restart.py)\n        \"\"\"\n        if os.path.exists(self.inputpath + '/pyconsolv.restart'):\n            self.restarter = RestartFile(self.inputpath)\n            self.restart = self.restarter.getstate()\n            print(Color.PURPLE + 'Restart file found!\\n' + Color.END)\n            os.remove(self.inputpath + '/pyconsolv.restart')\n\n    def prepareSolvent(self, method, basis, dsp, cpu):\n        print('You have selected a custom solvent, please input the path to the solvent xyz file:\\n')\n        self.solventParamPath = os.path.abspath(input())\n\n        print('Please enter the epsilon value for your custom solvent:\\n')\n        self.epsilon = input()\n\n        print('Please enter the refractive index value for your custom solvent:\\n')\n        self.refrac = input()\n\n        # print('Do you want to add this custom solvent to the list of available solvents?[y/n]\\n')\n        # add = str(input())\n        # while add.lower() not in ['y','n']:\n        #     print('Type \"y\" if you want to add this custom solvent to the list of available solvents or \"n\" if not:')\n        #     add = str(input())\n        # if add.lower() == 'y':\n        #     self.addSolvent = True\n        #     print('Give this solvent a unique abbreviations consisting of exactly 3 characters:\\n')\n        #     abb = str(input())\n        #     while len(abb) != 3:\n        #         print('It is mandatory to give exactly 3 characters! If you changed your mind please enter \"quit\"')\n        #         abb=str(input())\n        #         if abb.lower() == \"quit\":\n        #             self.addSolvent = False\n        #             print('Solvent files will not be added to pyConSolv!')\n        #             break\n        #     self.solventAbb = abb\n        #     print('You chose {} as abbreviation!'.format(self.solventAbb))\n\n        print(Color.GREEN + '''\n\n        ###################\n        Starting solvent parametrization in:\n        {}\n        ####################\n\n        '''.format('/'.join(self.solventParamPath.split('/')[:-1]) + '/solv_param') + Color.END)\n        self.solventParam = solventParametrizer(self.solventParamPath)\n        self.solventCPCM = '''\n\n        %CPCM       EPSILON      {}\n                    REFRAC       {}\n        END\n        '''.format(self.epsilon, self.refrac)\n        self.solventParam.run(method, basis, dsp, cpu, self.solventCPCM, 0)\n\n    def prepareCounterion(self, method, basis, dsp, cpu, charge, cpcm):\n\n        answered = False\n        while not answered:\n            answer = input('You system is charged, would you like to select an appropriate counterion? \\n y/n: ')\n            if answer == 'y':\n                print('Please choose one of the following counterions:\\n')\n                print(', '.join(self.counterIonsImplemented) + '\\n')\n                while not answered:\n                    ion = input()\n                    if ion not in self.counterIonsImplemented:\n                        print('Selected ion not supported, try again...\\n')\n                    else:\n                        print('Please enter the number of counterions to be used:\\n')\n                        amount = int(input())\n                        answered = True\n                        f = open(self.inputpath + '/counterion', 'w')\n                        f.write('{} {}'.format(ion, amount))\n                        f.close()\n            elif answer == 'n':\n                ion = ''\n                answered = True\n            else:\n                print('Wrong input, try again\\n')\n\n\n        if ion == 'custom':\n            print('You have chosen a custom counterion for your system, which needs to be parametrized\\n' +\n                  'Please provide a path to the location of an XYZ file containing your ion\\n')\n            self.ionParamPath = input()\n            chargeIon = input('Please enter the charge for your ion: \\n')\n            cIon = counterionParametrizer(self.ionParamPath)\n            if cpcm == 'custom':\n                cIon.run(method, basis, dsp, cpu, self.solventCPCM, int(chargeIon))\n            else:\n                cIon.run(method, basis, dsp, cpu, cpcm, int(chargeIon))\n        self.counterIon = ion\n\n\n\n    def setup(self, charge: int = 0, method: str = 'PBE0', basis: str = 'def2-SVP', dsp: str = 'D4',\n              cpcm: str = 'Water', cpu: int = 12, multiplicity:int  = 1, opt: bool = True) -> int:\n        \"\"\"\n        Run setup for creating the appropriate folders and parse XYZ file\n\n        Parameters:\n            :param int charge: charge of the complete system\n            :param string method: ORCA 5 method line\n            :param string basis: Basis set for ORCA calculations\n            :param string dsp: Dispersion corrections\n            :param string cpcm: CPCM solvation model solvent\n            :param int cpu: number of CPU cores to be used\n            :param int multiplicity: multiplicity for the system\n\n        Class variables:\n        \"\"\"\n        if cpcm == 'custom':\n            self.prepareSolvent(method, basis, dsp, cpu)\n        if cpcm not in self.solventsImplemented:\n            print(Color.RED + 'Selected solvent is not yet implemented\\n' + Color.END)\n            return 0\n        if cpcm in self.watermodels:\n            cpcmname = 'Water'\n        else:\n            cpcmname = cpcm\n\n        if charge != 0:\n            if not os.path.exists(self.inputpath+'/counterion'):\n                self.prepareCounterion(method, basis, dsp, cpu, charge, cpcmname)\n\n        if self.restart == 0:\n            self.xyz = XYZ(self.db_file, self.db_metal_file)\n            self.xyz.prepareInput(self.inputpath + '/input.xyz')\n            self.xyz = None\n            setup = Setup(self.inputpath + '/' + self.inputFile, charge=charge, multi = multiplicity, opt = opt)\n            setup.Method(method, basis, dsp, cpcmname, cpu, self.epsilon, self.refrac)\n            self.status = setup.run()\n            if self.status == 0:\n                error('Setup')\n                return 0\n\n        if cpcmname == 'custom':\n            shutil.copyfile('/'.join(self.solventParamPath.split('/')[:-1]) + '/SLV_param/SLV.frcmod',\n                            self.MCPB + '/SLV.frcmod')\n            shutil.copyfile('/'.join(self.solventParamPath.split('/')[:-1]) + '/SLV_param/SLV.mol2',\n                            self.MCPB + '/SLV.mol2')\n        else:\n            solvent = Solvent()\n            solvname = solvent.solventDict[cpcmname]\n            if cpcmname != 'Water':\n                shutil.copyfile(self.solventPath + '/{}.frcmod'.format(solvname),\n                                self.MCPB + '/{}.frcmod'.format(solvname))\n                shutil.copyfile(self.solventPath + '{}.mol2'.format(solvname),\n                                self.MCPB + '/{}.mol2'.format(solvname))\n\n        if self.counterIon == 'custom':\n            shutil.copyfile('/'.join(self.ionParamPath.split('/')[:-1]) + '/CTI_param/CTI.frcmod',\n                            self.MCPB + '/CTI.frcmod')\n            shutil.copyfile('/'.join(self.ionParamPath.split('/')[:-1]) + '/CTI_param/CTI.mol2',\n                            self.MCPB + '/CTI.mol2')\n        elif self.counterIon == '':\n            pass\n\n        else:\n            cIon = Counterion()\n            ions = ionlib()\n            if self.counterIon in list(ions.ionsinAmber.keys()):\n                ionname = ions.ionsinAmber[self.counterIon]\n            else:\n                ionname = cIon.counterionDict[self.counterIon]\n                shutil.copyfile(self.ionPath + '/{}.frcmod'.format(ionname),\n                                self.MCPB + '/{}.frcmod'.format(ionname))\n                shutil.copyfile(self.ionPath + '{}.mol2'.format(ionname),\n                                self.MCPB + '/{}.mol2'.format(ionname))\n\n        f = open(self.inputpath + '/simulation/solvent', 'w')\n        f.write(cpcmname)\n        f.close()\n\n        print(Color.GREEN + 'Setup is complete, moving on to ORCA calculations...\\n' + Color.END)\n\n        self.restarter = RestartFile(self.inputpath)\n\n        return 1\n\n    def orca(self, opt: bool = True):\n        \"\"\"\n        Run ORCA optimization and frequency calculations\n\n        Parameters:\n            :param opt bool: if set to False, a single point calculation will be performed\n        Class variables:\n        \"\"\"\n        try:\n            self.restarter.write('setup')\n        except AttributeError:\n            return 0\n\n        calculation = Calculation(self.inputpath + '/orca_calculations')\n        if self.hasMetal:\n            self.status = calculation.run(opt = opt)\n        else:\n            self.status = calculation.run(freq=False, opt = opt)\n            shutil.copyfile(self.inputpath + '/orca_calculations/opt/orca_opt.xyz', self.inputpath + '/MCPB_setup/input.xyz')\n        if self.status == 0:\n            error('ORCA Calculations')\n            return 0\n\n        print(Color.GREEN + 'ORCA Calculations complete, moving on to MCPB setup...' + Color.END)\n        self.restarter.write('orca')\n        return 1\n\n    def antechamber(self):\n        \"\"\"\n        Run antechamber for each generated fragment\n\n        Parameters:\n\n        Class variables:\n        \"\"\"\n        self.restarter.write('orca')\n        shutil.copyfile(self.inputpath + '/orca_calculations/opt/orca_opt.xyz', self.inputpath + '/MCPB_setup/input.xyz')\n        self.xyz = XYZ(self.db_file, self.db_metal_file)\n        self.xyz.prepareMCPB(self.inputpath + '/MCPB_setup/input.xyz')\n        pdbs = self.xyz.filenames\n\n        print('The following pdb files were created: \\n {}\\n'.format(' '.join(pdbs)))\n        print('Please enter fragment charges:\\n')\n\n        # get charges from user\n        window = Tk()\n        window.title('Fragment charge assignment')\n        start = GUI(window, self.MCPB, pdbs)\n        window.mainloop()\n        window.destroy()\n\n        # create mol2 files and run antechamber\n        self.xyz.writeMol2Files()\n        antechamberFiles = self.xyz.molNotCreated\n        ligands = np.array(self.xyz.ligands)\n        self.amber = amberInterface(self.MCPB)\n        for filename in antechamberFiles:\n            self.status = self.amber.antechamber(*filename)\n            if self.status == 0:\n                error('antechamber for {}'.format(filename))\n                return 0\n\n        print('Generating frcmod files for ligands:\\n')\n        for filename in ligands:\n            self.status = self.amber.runParmchk2(filename)\n            if self.status == 0:\n                error('parmchk2 for {}'.format(filename))\n                return 0\n        self.hasMetal = self.xyz.hasMetal\n\n        if self.hasMetal:  # if metal is detected, proceed with MCPB.py\n            metals = self.xyz.metals\n            self.xyz.writeMetalConnections(self.MCPB)  # write out metal connections file\n            self.xyz.writeConnections(self.MCPB)  # write out connections file\n            self.amber.inputFileGenerator(metals[0][1], ligands[:, 1])\n            self.restarter.write('frcmod')\n            return 1\n\n        else:  # if no metal, proceed with tleap, presumes only 1 ligand\n            # os.chdir(self.inputpath + '/equilibration/')\n            print(antechamberFiles)\n            shutil.copyfile(self.MCPB + '/' + str(antechamberFiles[0][0]) + '.mol2',\n                            self.MCPB + '/LIG.mol2')\n            shutil.copyfile(self.MCPB + '/' + antechamberFiles[0][0] + '.frcmod',\n                            self.MCPB + '/LIG.frcmod')\n            self.amber.tleapNoMetalSolv(self.MCPB)\n            self.restarter.write('frcmod')\n            return 1\n\n    def multiwfn(self, cores: int) -> int:\n        \"\"\"\n        Run Multiwfn charge calculations\n\n        Parameters:\n            :param int cores: number of cpu cores for Multiwfn\n\n        Class variables:\n        \"\"\"\n        self.restarter.write('frcmod')\n        print(Color.GREEN + 'Fragments have been prepared, running MultiWfn task...\\n\\n' + Color.END)\n        if self.xyz is None:\n            self.xyz = XYZ(self.db_file, self.db_metal_file)\n            self.xyz.hasMetal = self.hasMetal\n            self.xyz.readFilenames(self.MCPB)\n        if not self.hasMetal:\n            print('filenames')\n            print(self.xyz.filenames)\n            residues = []\n            for elem in self.xyz.filenames:\n                residues.append(elem.replace('.pdb',''))\n\n            multiwfn = MultiWfnInterface(self.inputpath + '/orca_calculations/opt/', orcaname='orca_opt')\n            self.status = multiwfn.run(cores)\n            self.xyz.hasMetal = False\n            self.xyz.readRESP(self.inputpath + '/orca_calculations/')\n            chargeChanger = ChargeChanger()\n\n            if len(residues) > 1:\n                for residue in residues:\n                    chargeChanger.change(self.MCPB + '/{}.mol2'.format(residue),\n                                         self.MCPB + '/{}x.mol2'.format(residue), residue, self.xyz.charges)\n                mol2parser = mol2Parser(self.MCPB,['{}x'.format(x) for x in residues])\n                mol2parser.writeCombinedMol2()\n                frcmodparser = frcmodParser(self.MCPB, residues)\n                frcmodparser.writeCombinedFrcmod()\n            else:\n                 chargeChanger.change(self.MCPB + '/A.mol2',\n                                         self.MCPB + '/LIG.mol2', 'A', self.xyz.charges)\n        else:\n            multiwfn = MultiWfnInterface(self.inputpath + '/orca_calculations/freq/')\n            self.status = multiwfn.run(cores)\n\n        if self.status == 0:\n            error('MultiWfn Calculations')\n            return 0\n        self.restarter.write('multiwfn')\n        return 1\n\n    def MCPB_script(self):\n        \"\"\"\n        Run MCPB.py for the system\n\n        Parameters:\n\n        Class variables:\n        \"\"\"\n\n        if not self.hasMetal:\n            self.restarter.write('mcpb')\n            return 1\n\n        self.restarter.write('multiwfn')\n\n        print(Color.GREEN + 'Converting ORCA output to MCPB.py compatible input...\\n' + Color.END)\n\n        faker = Faker(self.inputpath + '/orca_calculations/freq/')\n        faker.fakecrds()\n        # faker.fakeesp()\n        faker.fakeforce()\n\n        shutil.copyfile(self.inputpath + '/orca_calculations/freq/fakechk.fchk',\n                        self.inputpath + '/MCPB_setup/LIG_small_opt.fchk')\n        shutil.copyfile(self.inputpath + '/orca_calculations/freq/fakelog.log',\n                        self.inputpath + '/MCPB_setup/LIG_small_fc.log')\n\n\n        print(Color.GREEN + 'Proceeding with MCPB steps...\\n' + Color.END)\n\n        if self.amber is None:\n            self.amber = amberInterface(self.MCPB)\n\n        self.status = self.amber.runMCPB('1')\n\n        if self.status == 0:\n            error('MCPB step 1')\n            return 0\n\n        if not self.amber.checkMCPBBonds(self.MCPB):\n            self.status = self.amber.runMCPB('1')\n\n            if self.status == 0:\n                error('MCPB step 1')\n                return 0\n\n        self.status = self.amber.runMCPB('2')\n\n        if self.status == 0:\n            error('MCPB step 2')\n            return 0\n\n        if self.xyz is None:\n            self.xyz = XYZ(self.db_file, self.db_metal_file)\n            self.xyz.path = self.inputpath + '/MCPB_setup/'\n            self.xyz.hasMetal = self.hasMetal\n\n        if self.xyz.path is None:\n            self.xyz.path = self.inputpath + '/MCPB_setup/'\n            self.xyz.hasMetal = self.hasMetal\n        self.xyz.createFinalMol2(self.inputpath)\n\n        self.status = self.amber.runMCPB('4')\n\n        if self.status == 0:\n            error('MCPB step 4')\n            return 0\n\n        self.parameterChecker = ParameterChecker(self.MCPB)\n        self.parameterChecker.run()\n\n        self.restarter.write('mcpb')\n        return 1\n\n    def tleap(self, solvent: str, boxsize: int = 10) -> int:\n        \"\"\"\n        Run tleap\n\n        Parameters:\n            :param string solvent: solvent for your box.\n\n        Class variables:\n        \"\"\"\n        self.restarter.write('mcpb')\n        self.boxsize = boxsize\n\n        os.chdir(self.MCPB)\n        print('Solvent of choice is: {}'.format(solvent))\n        if solvent not in self.solventsImplemented:\n            print(Color.RED + 'Selected solvent is not yet implemented\\n' + Color.END)\n            return 0\n\n        if self.amber is None:\n            self.amber = amberInterface(self.MCPB)\n\n        if self.hasMetal:\n            solutename = 'mol'\n        else:\n            solutename = 'LIG'\n        solv = Solvent()\n        solv.applyItem(solvent, self.MCPB + '/LIG_tleap.in',\n                          self.MCPB + '/LIG_tleap.in', self.MCPB, solutename)\n        if os.path.exists(self.inputpath+'/counterion'):\n            f = open(self.inputpath+'/counterion','r')\n            for line in f:\n                amount = line.split()[1]\n                self.counterion = line.split()[0]\n            f.close()\n        else:\n            self.counterion = ''\n            amount = 0\n        if self.counterIon != '':\n            ion = Counterion()\n            ionsAmber = ionlib()\n            if self.counterIon in list(ionsAmber.ionsinAmber.keys()):\n                ion.applyItem(self.counterIon, self.MCPB + '/LIG_tleap.in',\n                              self.MCPB + '/LIG_tleap.in', self.MCPB, solutename, amount)\n            else:\n                ion.applyItem(self.counterIon, self.MCPB + '/LIG_tleap.in',\n                                  self.MCPB + '/LIG_tleap.in', self.MCPB, solutename, amount)\n        self.amber.tleapChecker(self.MCPB)\n        self.amber.changeBoxSize(self.MCPB + '/LIG_tleap.in',self.boxsize- self.amber.defaultbox)\n        self.status = self.amber.runTleap()\n\n        if self.status == 0:\n            error('Tleap')\n            return 0\n\n        self.restarter.write('tleap')\n\n        print('Parametrization complete!\\n')\n        print('Solvent of choice is: {}\\n'.format(solvent))\n        return 1\n\n    def equilibration(self, cpu: int = 12, engine = 'amber'):\n        \"\"\"\n        Run system equilibration\n\n        Parameters:\n            :param int cpu = number of cpus to be used for the equilibration\n            :param string engine = MD engine to be used for equilibration\n\n        Class variables:\n        \"\"\"\n        self.engine = engine\n        self.restarter.write('tleap')\n\n        print(Color.GREEN + 'Setting up system equilibration...\\n' + Color.END)\n        print('Writing input files in the equilibration folder...\\n')\n\n        if self.xyz is None:\n            self.xyz = XYZ(self.db_file, self.db_metal_file)\n            self.xyz.readFilenames(self.MCPB)\n            if len(self.xyz.filenames) == 1:\n                self.hasMetal = False\n\n        #old amber only equilibration\n        # shutil.copyfile(self.MCPB + '/LIG_solv.inpcrd', self.inputpath + '/equilibration/00.rst7') # different for different engines\n        # shutil.copyfile(self.MCPB + '/LIG_solv.prmtop', self.inputpath + '/equilibration/LIG_solv.prmtop')\n        #\n        # if self.amber is None:\n        #     self.amber = amberInterface(self.MCPB)\n        # self.amber.equil(self.inputpath)\n        #\n        # print('Done!\\n')\n        # print(Color.GREEN + 'Starting equilibration...' + Color.END)\n        #\n        # self.status = self.amber.equilibrate(cpus = cpu)\n\n        shutil.copyfile(self.MCPB + '/LIG_solv.inpcrd', self.inputpath + '/equilibration/00.rst7')\n        shutil.copyfile(self.MCPB + '/LIG_solv.inpcrd', self.inputpath + '/equilibration/LIG_solv.inpcrd')\n        shutil.copyfile(self.MCPB + '/LIG_solv.prmtop', self.inputpath + '/equilibration/LIG_solv.prmtop')\n\n        self.MDEngine = MDEngine(self.MCPB, engine = self.engine)\n        print('Done!\\n')\n        print(Color.GREEN + 'Starting equilibration...' + Color.END)\n        self.status = self.MDEngine.run(self.inputpath, cpus = cpu)\n\n\n        if self.status == 0:\n            error('Equilibration')\n            print('If error stems from grid changes, you can modify the input file for the offending step and restart '\n                  'the equilibration with the provided restart script in\\n {}\\n'.format(self.inputpath + '/equilibration'))\n            return 0\n        self.restarter.write('equilibration')\n        return 1\n\n    def prepareSimulation(self, solvent: str, engine: str = 'amber'):\n        \"\"\"\n        Function to copy scripts and inputs needed for running and analysing the simulation\n\n        Parameters:\n            :param string solvent = 3 letter keyword for the solvent used for the simulation\n\n\n        \"\"\"\n        self.restarter.write('equilibration')\n        print('Preparing simulation...\\n')\n        sourceloc = os.path.split(__file__)[0]\n        try:\n            # PyConSolv / scripts_and_inputs\n            shutil.copyfile(self.MCPB + '/LIG_dry.prmtop', self.inputpath + '/simulation/LIG_dry.prmtop')\n            shutil.copyfile(self.MCPB + '/LIG_solv.prmtop', self.inputpath + '/simulation/LIG_solv.prmtop')\n            shutil.copyfile(sourceloc + '/scripts_and_inputs/align_dry.in', self.inputpath + '/simulation/align_dry.in')\n            shutil.copyfile(sourceloc + '/scripts_and_inputs/dry_sim.in', self.inputpath + '/simulation/dry_sim.in')\n            shutil.copyfile(sourceloc + '/scripts_and_inputs/align.in', self.inputpath + '/simulation/align.in')\n            # shutil.copyfile(sourceloc + '/scripts_and_inputs/cluster_kmeans.in', self.inputpath + '/simulation/cluster_kmeans.in')\n            shutil.copyfile(sourceloc + '/scripts_and_inputs/dry.vmd', self.inputpath + '/simulation/dry.vmd')\n            shutil.copyfile(sourceloc + '/scripts_and_inputs/solv.vmd', self.inputpath + '/simulation/solv.vmd')\n            shutil.copyfile(sourceloc + '/scripts_and_inputs/dry_aligned.vmd', self.inputpath + '/simulation/dry_aligned.vmd')\n            # shutil.copyfile(sourceloc + '/scripts_and_inputs/strip.sh', self.inputpath + '/simulation/strip.sh')\n        except:\n            print('Failed to copy files into simulation folder')\n            return 1\n\n        if engine == 'gromacs':\n            if self.MDEngine == None:\n                self.MDEngine = self.MDEngine = MDEngine(self.MCPB, engine = engine)\n                self.MDEngine.MD.checkpath()\n\n            executable = self.MDEngine.MD.executable\n\n            shutil.copyfile(self.MCPB + '/LIG_dry.top', self.inputpath + '/simulation/LIG_dry.top')\n            shutil.copyfile(sourceloc + '/scripts_and_inputs/simulation_gro.mdp', self.inputpath + '/simulation/simulation_gro.mdp')\n            shutil.copyfile(self.inputpath + '/equilibration/LIG_solv.top', self.inputpath + '/simulation/LIG_solv.top')\n            shutil.copyfile(self.inputpath + '/equilibration/index.ndx', self.inputpath + '/simulation/index.ndx')\n            shutil.copyfile(self.inputpath + '/equilibration/npt.gro', self.inputpath + '/simulation/npt.gro')\n            shutil.copyfile(self.inputpath + '/equilibration/npt.cpt', self.inputpath + '/simulation/npt.cpt')\n\n            f = open(self.inputpath + '/simulation/run_simulation_gro.sh', 'w')\n            f.write('{} grompp -f simulation_gro.mdp -n index.ndx -c npt.gro -t npt.cpt -p LIG_solv.top -o sim-01.tpr\\n'.format(executable))\n            f.write('{} mdrun -deffnm sim-01 -nb gpu\\n'.format(executable))\n            f.close()\n\n        else:\n            shutil.copyfile(self.inputpath + '/equilibration/21.rst7', self.inputpath + '/simulation/eq.rst7')\n            shutil.copyfile(sourceloc + '/scripts_and_inputs/run_simulation.sh', self.inputpath + '/simulation/run-simulation.sh')\n            shutil.copyfile(sourceloc + '/scripts_and_inputs/simulation.in', self.inputpath + '/simulation/simulation.in')\n\n        solv = Solvent()\n        if solvent in self.watermodels:\n            solvent = 'Water'\n        solvID = solv.solventDict[solvent]\n        self.modifyDryScript(self.inputpath + '/simulation/dry_sim.in', solvID)\n        self.modifyDryScript(self.inputpath + '/simulation/solv.vmd', solvID)\n        self.restarter.write('DONE')\n        print('Simulation setup complete, please execute the run_simulation.sh script in:\\n {}\\n to '\n              'begin a 100ns cmd production run.\\n'.format(self.inputpath + '/simulation'))\n        print('A quick analysis of the simulation run can be performed using the \\\"pyconsolv sim-01 -a\\\" command, in your simulation folder\\n\\n')\n\n        if self.addSolvent == True:\n            Copier(self.inputpath+'/Solvent/solv_param/SLV.frcmod',\n                   self.solventPath+'/{}.frcmod'.format(self.solventAbb)).copy()\n            Copier(self.inputpath + '/Solvent/solv_param/SLV.mol2',\n                   self.solventPath + '/{}.mol2'.format(self.solventAbb)).copy()\n\n        print(Color.GREEN + 'My job here is done!' + Color.END)\n\n        return 0\n\n\n\n    def modifyDryScript(self, path, solvent):\n        \"\"\"\n                Modify the dry script to account for the correct solvent.\n\n                Parameters:\n                    :param str path: location of dry_sim.in cpptraj script\n                    :param str solvent: new solvent label\n        \"\"\"\n        f = open(path, 'r')\n        tmp = []\n        for line in f:\n            if 'SLV' in line:\n                line = line.replace('SLV', solvent)\n            tmp.append(line)\n        f.close()\n\n        f = open(path, 'w')\n        for line in tmp:\n            f.write(line)\n        f.close()\n\n    def metalCheck(self):\n        \"\"\"\n        Function to check whether a metal is present in the input structure\n\n        \"\"\"\n        f = open(self.path, 'r')\n        for line in f:\n            if not line.split():\n                continue\n            elif line.split()[0].upper() in self.metals:\n                self.hasMetal = True\n                break\n        f.close()\n\n    def run(self, charge: int = 0, method: str = 'PBE0', basis: str = 'def2-SVP', dsp: str = 'D4', cpu: int = 12,\n            solvent: str = 'Water', multiplicity: int = 1, engine: str = 'amber', opt: bool = True, box: int = 20):\n        \"\"\"\n        Run the conformer generation\n\n        Parameters:\n            :param str solvent: solvent to be used for MD simulation, check solvent list for available options\n            :param int charge: charge of the complete system\n            :param string method: ORCA 5 method line\n            :param string basis: Basis set for ORCA calculations\n            :param string dsp: Dispersion corrections\n            :param int cpu: number of CPU cores to be used\n            :param str solvent: solvent to be used\n            :param int multiplicity: multiplicity of the system\n            :param str engine: MD engine to be used for equilibration/simulation\n            :param bool opt : if set to False, no geometry optimization will be performed\n            :param int box : set box size for amber tleap\n\n        Class variables:\n        \"\"\"\n        print(Color.GREEN + 'Entering initial setup...\\n\\n' + Color.END)\n\n\n        self.checkRestart()\n        self.setup(charge, method, basis, dsp, solvent, cpu, multiplicity, opt)\n\n        if self.restart < 2:\n            if self.orca(opt = opt) == 0:\n                return\n\n        if self.restart < 3:\n            if self.antechamber() == 0:\n                return\n            if not self.hasMetal:\n                print('No metal has been found in your file, switching to simple parametrization')\n                self.multiwfn(cpu)\n                self.restart = 6  # skip mcpb and multiwfn if no metal\n\n        if self.restart < 5:\n            if self.multiwfn(cpu) == 0:\n                return\n\n        if self.restart < 6:\n            if self.MCPB_script() == 0:\n                return\n\n        if self.restart < 7:\n            if self.tleap(solvent, box) == 0:\n                return\n\n        if self.restart < 8:\n            if self.equilibration(cpu, engine) == 0:\n                return\n\n        if self.restart < 9:\n            if self.prepareSimulation(solvent, engine) == 0:\n                return\n        if self.restart == 9:\n            print('This structure has already completed parametrization, please make sure you are using the correct input\\n')
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/PyConSolv/ConfGen.py b/src/PyConSolv/ConfGen.py
--- a/src/PyConSolv/ConfGen.py	(revision c09c1d1d0d85c6e7c96c0fb2e2894ec6dbbb1454)
+++ b/src/PyConSolv/ConfGen.py	(date 1702494484789)
@@ -96,7 +96,7 @@
         self.refrac = None
         self.epsilon = None
         self.solventParamPath = None
-        self.version = '1.0.3.1'
+        self.version = '1.0.4'
         self.metals = ['LI', 'BE', 'NA', 'MG', 'AL', 'SI', 'K', 'CA', 'SC', 'TI', 'V', 'CR', 'MN', 'FE',
                        'CO', 'NI', 'CU', 'ZN',
                        'GA', 'GE', 'AS', 'SE', 'BR', 'RB', 'SR', 'Y', 'ZR', 'NB', 'MO', 'TC', 'RU', 'RH', 'PD', 'AG',
