# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['procaaso_state_machine']

package_data = \
{'': ['*']}

install_requires = \
['pydantic>=1.10.9,<2.0.0', 'pytest>=7.0,<8.0']

setup_kwargs = {
    'name': 'procaaso-state-machine',
    'version': '0.0.1',
    'description': '',
    'long_description': '# procaaso-state-machine\nThe ProCaaSo based state machine is an ENS centric implementaion of a finite state machine. It\'s goal is to provide users a state machine that works well within the ProCaaSo App loop, its handlers, classes, methods and other such details will be outlined below. \n\n\n# StateMachine Class\n\nThe `StateMachine` class is a deterministic finite acceptor state machine designed for use within the ProCaaSo framework. It works in conjunction with the `State` object from the `procaaso_state` module. State objects should be defined and complete before addition to the `StateMachine`. It is recommended to handle `StateMachine` logic with try-except statements to catch any errors.\n\n## Initialization\n\n```python\nfrom procaaso_state_machine.procaaso_state import State\n\nstate_machine_instance = StateMachine()\n```\n\n## Attributes\n\n- `instruments` (dict): A dictionary containing each instrument object added to the machine.\n- `__states` (dict): A dictionary of `State` objects that the state machine keeps track of.\n- `__currentStateId` (int): Tracks identification for the current state.\n- `__currentTransitions` (list): A list of current transitions based on the current state.\n- `__isConfigured` (bool): Tracks whether the machine is able to enter its initial state.\n\n## Methods\n\n### `add_state(state: State)`\n\nAdd a `State` object to the `StateMachine`.\n\n```python\nstate_machine_instance.add_state(my_state_object)\n```\n\nRaises:\n- `KeyError`: If the state ID is already present in the `StateMachine`.\n- `Exception`: If an unexpected exception occurs during the process.\n\n### `get_states() -> dict`\n\nGet the dictionary containing the `State` objects in the `StateMachine`.\n\n```python\nstates_dict = state_machine_instance.get_states()\n```\n\nRaises:\n- `Exception`: If an unexpected exception occurs during the process.\n\n### `get_current_state_id() -> int`\n\nGet the ID of the current state.\n\n```python\ncurrent_state_id = state_machine_instance.get_current_state_id()\n```\n\nRaises:\n- `Exception`: If an unexpected exception occurs during the process.\n\n### `get_current_transitions() -> list`\n\nGet the list of current transitions.\n\n```python\ncurrent_transitions_list = state_machine_instance.get_current_transitions()\n```\n\nRaises:\n- `Exception`: If an unexpected exception occurs during the process.\n\n### `transition_state(newStateId: int)`\n\nTransition to a new state.\n\n```python\nstate_machine_instance.transition_state(2)\n```\n\nRaises:\n- `Exception`: If an unexpected exception occurs during the process.\n\n### `start_state_machine(initialStateId: int)`\n\nStart the `StateMachine`.\n\n```python\nstate_machine_instance.start_state_machine(1)\n```\n\nRaises:\n- `Exception`: If the `StateMachine` is already configured and/or running.\n\n### `add_instrument(instruments: dict)`\n\nAdd instruments to the `StateMachine`.\n\n```python\nstate_machine_instance.add_instrument({"instrument1": data1, "instrument2": data2})\n```\n\nRaises:\n- `TypeError`: If the provided instruments are not of type \'dict\'.\n- `Exception`: If an unexpected exception occurs during the process.\n\n### `get_instruments() -> dict`\n\nGet the instruments dictionary from the `StateMachine`.\n\n```python\ninstruments_dict = state_machine_instance.get_instruments()\n```\n\nRaises:\n- `Exception`: If an unexpected exception occurs during the process.\n\n### `get_state_start_time() -> float`\n\nGet the start time of the state.\n\n```python\nstart_time = state_machine_instance.get_state_start_time()\n```\n\nRaises:\n- `Exception`: If retrieving the start time fails.\n\n### `get_time_elapsed_in_state() -> float`\n\nGet the elapsed time since the state started.\n\n```python\nelapsed_time = state_machine_instance.get_time_elapsed_in_state()\n```\n\nRaises:\n- `Exception`: If retrieving the elapsed time fails.\n\n# State Class\n\nThe `State` class represents a state object within the ProCaaSo framework. Each state must have a unique ID, and routines and transitions are added manually through the class methods.\n\n## Initialization\n\n```python\nfrom typing import Callable\nfrom procaaso_state import State\n\nstate_instance = State(0)\n```\n\n### Attributes\n\n- `__apartOfStateMachine` (bool): A boolean to track if the state is part of a state machine.\n- `__routines` (dict): A dictionary containing the routines registered to run.\n- `__transitions` (list): A list of all valid states to transition to.\n- `id` (int): The state number, each state should only have one ID.\n\n## Methods\n\n### `set_routine(routineName: str, routine: Callable)`\n\nSet a routine with a given name in the object\'s routines dictionary.\n\n```python\nstate_instance.set_routine("my_routine", my_callable_routine)\n```\n\nRaises:\n- `TypeError`: If routineName is not of type \'str\' or routine is not of type \'Callable\'.\n- `Exception`: If an unexpected exception occurs during the process.\n- `Exception`: If the state is already part of a state machine.\n\n### `get_routines() -> dict`\n\nGet the dictionary containing the routines registered in the state.\n\n```python\nroutines_dict = state_instance.get_routines()\n```\n\n### `set_transition(transitionId: int)`\n\nSet a transition ID in the object\'s transitions list.\n\n```python\nstate_instance.set_transition(123)\n```\n\nRaises:\n- `TypeError`: If transitionId is not of type \'int\'.\n- `Exception`: If an unexpected exception occurs during the process.\n- `Exception`: If the state is already part of a state machine.\n\n### `get_transitions() -> List[int]`\n\nGet the list of valid state transitions from the current state.\n\n```python\ntransitions_list = state_instance.get_transitions()\n```\n\n### `set_state_machine()`\n\nSet the `__apart_of_state_machine` variable. Do not recommend users accessing this directly. A State may only be added to a State Machine object once.\n\nRaises:\n- `Exception`: If the state is already part of a state machine.\n\n### `get_state_machine() -> bool`\n\nGet the `__apart_of_state_machine` of the state object.\n\n```python\nisApartOfStateMachine = state_instance.get_state_machine()\n```\n\n### `get_id() -> int`\n\nGet the ID of the state.\n\n```python\nstate_id = state_instance.get_id()\n```\n\n**Note**: Methods prefixed with double underscores (e.g., `__set_routine`, `__set_current_state_id`) are intended for internal use and should not be accessed directly by users.',
    'author': 'Procaaso',
    'author_email': 'mdorado@consynsys.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
