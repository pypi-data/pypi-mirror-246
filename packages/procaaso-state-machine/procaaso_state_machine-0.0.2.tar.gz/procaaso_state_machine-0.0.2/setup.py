# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['procaaso_state_machine']

package_data = \
{'': ['*']}

install_requires = \
['pydantic>=1.10.9,<2.0.0', 'pytest>=7.0,<8.0']

setup_kwargs = {
    'name': 'procaaso-state-machine',
    'version': '0.0.2',
    'description': '',
    'long_description': '# procaaso-state-machine\nThe ProCaaSo based state machine is an ENS centric implementaion of a finite state machine. It\'s goal is to provide users a state machine that works well within the ProCaaSo App loop, its handlers, classes, methods and other such details will be outlined below. \n\n\n# StateMachine Class\n\nA deterministic finite acceptor state machine designed for use within the ProCaaSo framework.\n\nThis machine works in conjunction with the \'State\' object from procaaso_state.\nState objects are not modifiable after they are added to the state machine instance.\nThe state object should be defined and complete before addition to the StateMachine.\nRecommended practice is to place StateMachine logic with try-except statements to catch any errors.\n\n## Initialization\n\n```python\nstate_machine_instance = StateMachine()\n\n```\n\n### Attributes\n\n- `instruments` (dict): Dictionary containing each instrument object added to a machine.\n- `__states` (dict): A dictionary of state class objects that the state machine will keep track of.\n- `__currentStateId` (int): Tracks identification for the current state.\n- `__currentTransitions` (list): A dictionary of lists, where the key is state, each sublist containing the state\'s possible transitions.\n- `__isConfigured` (bool): Tracks whether the machine is able to enter its initial state.\n- `__stateStartTime` (float): Timestamp indicating the start time of the current state.\n- `__currentEvent` (Event): The current event associated with the state machine.\n\n\n## Methods\n\n### Method: `run_routine(self, routineName: str = None, **kwargs)`\n\nRun a routine or all routines associated with the current state. Amend the \'stateMachine\' object into the kwargs of the routines for easy access.\n\nIf no routine name is supplied, all routines housed in a state will be executed in the order they are provided. If a routine name is specified, it will run that routine only.\n\nIf kwargs are provided and a routine name is supplied, the specified routine will receive the kwargs. If kwargs are provided and no routine name is supplied, all routines will receive the same kwargs.\n\n#### Args:\n- `routineName` (str, optional): The name of the routine to run. Defaults to None.\n- `**kwargs`: Additional keyword arguments to pass to the routines.\n\n#### Raises:\n- `Exception`: If there is an issue running the routine(s).\n\n#### Usage:\n```python\nstate_machine_instance.run_routine()\nstate_machine_instance.run_routine("Main Routine")\nstate_machine_instance.run_routine("Main Routine", returnKwarg="I\'m a Keyword Function", anotherVariable="I\'m another KWARG")\n```\n\n### Method: `set_currentEvent(self, event: Event)`\n\nSets the current event object.\n\n#### Parameters:\n- `event` (Event): The event object to set as the current event.\n\n#### Raises:\n- `Exception`: If the provided event is not of type \'Event\'.\n\n#### Usage:\n```python\nobj.set_currentEvent(my_event)\n```\n### Method: `get_currentEvent(self)`\n\nRetrieve the current event object.\n\n#### Raises:\n- `Exception`: If there is no current event set.\n\n#### Returns:\n- `Event`: The current event object.\n\n#### Usage:\n```python\ncurrent_event = obj.get_currentEvent()\n```\n### Method: `clear_currentEvent(self) -> None`\n\nClear the current event in the StateMachine object.\n\n#### Usage:\n```python\nstate_machine_instance.clear_currentEvent()\n```\n### Method: `add_state(self, state: State)`\n\nAdd a State object to the StateMachine.\n\n#### Parameters:\n- `state` (State): The State object to be added.\n\n#### Raises:\n- `KeyError`: If the state ID is already present in the StateMachine.\n- `Exception`: If an unexpected exception occurs during the process.\n\n#### Usage:\n```python\nstate_machine_instance.add_state(my_state_object)\n```\n\n### Method: `get_states(self)`\n\nGet the dictionary containing the State objects in the StateMachine.\n\n#### Returns:\n- `dict`: The dictionary of State objects.\n\n#### Raises:\n- `Exception`: If an unexpected exception occurs during the process.\n\n#### Usage:\n```python\nstates_dict = state_machine_instance.get_states()\n```\n### Method: `get_current_state_id(self)`\n\nGet the ID of the current state.\n\n#### Returns:\n- `int`: The ID of the current state.\n\n#### Raises:\n- `Exception`: If an unexpected exception occurs during the process.\n\n#### Usage:\n```python\ncurrent_state_id = state_machine_instance.get_current_state_id()\n```\n\n### Method: `get_current_transitions(self)`\n\nGet the list of current transitions.\n\n#### Returns:\n- `list`: The list of current transitions.\n\n#### Raises:\n- `Exception`: If an unexpected exception occurs during the process.\n\n#### Usage:\n```python\ncurrent_transitions_list = state_machine_instance.get_current_transitions()\n```\n\n### Method: `transition_state(self, newStateId: int)`\n\nTransition to a new state.\n\n#### Parameters:\n- `newStateId (int)`: The ID of the new state.\n\n#### Raises:\n- `Exception`: If an unexpected exception occurs during the process.\n\n#### Usage:\n```python\nstate_machine_instance.transition_state(2)\n```\n\n### Method: `start_state_machine(self, initialStateId: int)`\n\nStart the StateMachine.\n\n#### Parameters:\n- `initialStateId (int)`: The ID of the initial state.\n\n#### Raises:\n- `Exception`: If the StateMachine is already configured and/or running.\n\n#### Usage:\n```python\nstate_machine_instance.start_state_machine(1)\n```\n\n### Method: `get_is_configured(self)`\n\nGet the value of the isConfigured attribute.\n\n#### Returns:\n- `bool`: The value of the isConfigured attribute.\n\n#### Raises:\n- `Exception`: If an unexpected exception occurs during the process.\n\n#### Usage:\n```python\nis_configured_value = state_machine_instance.get_is_configured()\n```\n\n### Method: `add_instrument(self, instruments: dict[str, Any])`\n\nAdd instruments to the StateMachine.\n\n#### Parameters:\n- `instruments` (`dict`): An open-ended function so the user can define the data structure they wish to use for their instruments. If the instrument dictionary is already present in the StateMachine dictionary, it will simply update the first entry.\n\n#### Raises:\n- `TypeError`: If the provided instruments are not of type \'dict\'.\n- `Exception`: If an unexpected exception occurs during the process.\n\n#### Usage:\n```python\nstate_machine_instance.add_instrument({"instrument1": data1, "instrument2": data2})\n```\n\n### Method: `get_instruments(self)`\n\nGet the instruments dictionary from the StateMachine.\n\n#### Returns:\n- `dict`: The dictionary containing instruments.\n\n#### Raises:\n- `Exception`: If an unexpected exception occurs during the process.\n\n#### Usage:\n```python\ninstruments_dict = state_machine_instance.get_instruments()\n```\n\n### Method: `get_state_start_time(self)`\n\nGet the start time of the state.\n\n#### Returns:\n- `float`: The start time of the state.\n\n#### Raises:\n- `Exception`: If retrieving the start time fails.\n\n#### Usage:\n```python\nstart_time = self.get_state_start_time()\n```\n\n### Method: `get_time_elapsed_in_state(self)`\n\nGet the elapsed time since the state started.\n\n#### Returns:\n- `float`: The elapsed time since the state started.\n\n#### Raises:\n- `Exception`: If retrieving the elapsed time fails.\n\n#### Usage:\n```python\nelapsed_time = self.get_time_elapsed_in_state()\n```\n# State Class\nA class designed to be used with the ProCaaSo State Machine\n\n## Initialization\n\n```python\nstate = State(0)\n\n```\n### Attributes:\n\n- `__apartOfStateMachine (bool)`: A boolean to track if the state is a part of a state machine.\n- `__routines (dict)`: A dictionary containing the routines registered to run.\n- `__transitions (list)`: A list of all valid states to transition to.\n- `id (int)`: The state number. Each state should only have one ID.\n\n## Methods\n### Method: `__init__(self, id: int) -> None`\n\nInitialize a State object. All routines and transitions must be added manually through the class methods.\n\n#### Parameters:\n- `id (int)`: The state number. Each state should only have one ID.\n\n#### Raises:\n- `TypeError`: If the provided ID is not of type \'int\'.\n\n#### Usage:\n```python\nstate_instance = State(0)\n```\n\n### Method: `set_routine(self, routineName: str, routine: Callable)`\n\nSet a routine with a given name in the object\'s routines dictionary. The order in which the routines are added determines the order in which they will be executed. If a routine name is already present in the states dictionary of routines, the routine will be updated, not added. Thus, routine names must be unique within a state object. It is required that all routines accept kwargs by default, such that on call the routines can be passed information.\n\n#### Parameters:\n- `routineName (str)`: The name of the routine.\n- `routine (Callable)`: The callable object representing the routine.\n\n#### Raises:\n- `TypeError`: If routineName is not of type \'str\' or routine is not of type \'Callable\'.\n- `Exception`: If an unexpected exception occurs during the process.\n- `Exception`: If state is already a part of the state machine, raises an exception.\n\n#### Usage:\n```python\nobj.set_routine("my_routine", my_callable_routine)\n```\n### Method: `get_routines(self) -> dict`\n\nGet the dictionary containing the routines registered in the state.\n\n#### Returns:\n- `dict`: The dictionary of routines.\n\n#### Usage:\n```python\nroutines_dict = obj.get_routines()\n```\n### Method: `set_transition(self, transitionId: int)`\n\nSet a transition ID in the object\'s transitions list.\n\n#### Parameters:\n- `transitionId` (int): The ID of the transition.\n\n#### Raises:\n- `TypeError`: If transitionId is not of type \'int\'.\n- `Exception`: If an unexpected exception occurs during the process.\n- `Exception`: If state is already a part of the state machine, raises an exception.\n\n#### Usage:\n```python\nobj.set_transition(123)\n```\n\n### Method: `get_transitions(self) -> List[int]`\n\nGet the list of valid state transitions from the current state.\n\n#### Returns:\n- `List[int]`: The list of transition IDs.\n\n#### Usage:\n```python\ntransitions_list = obj.get_transitions()\n```\n\n### Method: `get_apartOfStateMachine(self) -> bool`\n\nCheck if the state is a part of a state machine.\n\n#### Returns:\n- `bool`: True if the state is a part of a StateMachine object, False otherwise.\n\n#### Usage:\n```python\nisApartOfStateMachine = obj.get_apartOfStateMachine()\n```\n\n### Method: `get_id(self) -> int`\n\nGet the ID of the state.\n\n#### Returns:\n- `int`: The state ID.\n\n#### Usage:\n```python\nstate_id = obj.get_id()\n```\n\n# Event Class\nA class to be passed to the ProCaaSo state machine to help build event driven development\n\n## Initialization\n\n```python\nevent = Event(\'Example Event\', {\'Actuation\': 5})\n\n```\n\n### Attributes\n\n- `set_actuations` (dict[str,Any]): Dictionary containing each actuation.\n- `__set_eventType` (str): A string with the type of the event.\n\n## Methods\n### Method: `__init__(self, eventType: str, actuations: Dict[str, Any] = {}) -> None`\n\nInitialize the Event object with the specified event type and optional actuations.\n\n#### Parameters:\n- `eventType (str)`: The type of the event.\n- `actuations (Dict[str, Any])`: A dictionary containing actuations associated with the event. Default is an empty dictionary.\n\n#### Raises:\n- `Exception`: If an unexpected exception occurs during initialization.\n\n#### Usage:\n```python\nevent = Event("eventType", {"key": "value"})\n```\n\n### Method: `set_actuations(self, actuationsDict: Dict[str, Any])`\n\nSet the actuations for the event object, overwriting any previous actuations.\n\n#### Parameters:\n- `actuationsDict (Dict[str, Any])`: A dictionary containing actuations.\n\n#### Raises:\n- `Exception`: If the dictionary structure is invalid.\n\n#### Usage:\n```python\nevent.set_actuations({"key": "value"})\n```\n\n### Method: `get_actuations(self)`\n\nGet the actuations associated with the event.\n\n#### Raises:\n- `Exception`: If failed to retrieve actuations.\n\n#### Usage:\n```python\nactuations = event.get_actuations()\n```\n\n### Method: `get_eventType(self)`\n\nGet the event type associated with the event.\n\n#### Raises:\n- `Exception`: If failed to retrieve the event type.\n\n#### Usage:\n```python\neventType = event.get_eventType()\n```',
    'author': 'Procaaso',
    'author_email': 'mdorado@consynsys.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
