"""
Management of provisioning storage in the ECC.
Information generated by provisioning is stored in ECC slot 8 for use by application
firmware.
"""

from logging import getLogger


class EccStorage:
    """
    Class used to manage ECC storage

    :param protocol: Protocol object to use for communication
    :type protocol: object
    :param slot: ECC slot number
    :type slot: int
    """

    # Data item types. These definitions must be shared with the FW.
    EMPTY = 0
    AWS_THINGNAME = 1
    AWS_ENDPOINT = 2
    AZURE_ID_SCOPE = 3
    AZURE_IOT_HUB_NAME = 4
    AZURE_DEVICE_ID = 5
    GOOGLE_PROJECT_ID = 6
    GOOGLE_PROJECT_REGION = 7
    GOOGLE_REGISTRY_ID = 8
    GOOGLE_DEVICE_ID = 9
    NUM_TYPES = 10    # Placeholder, keep this last

    def __init__(self, protocol, slot=8):
        self.protocol = protocol
        self.slot = slot
        self.slot_len = 0
        self.offset = 0
        self.blob = None
        self.logger = getLogger(__name__)

    def build_item(self, datatype, data):
        """
        Create data item with 16-bit data header

        Header is 16 bits represented as little-endian 2-byte array

        .. code-block:: text

            +15-----9-8------------------- 0
            |  type  |    next (offset)    |
            +.-----------------------------\

            It is laid out as 2 bytes in little-endian fashion immediately prior to the data blob.
                +7--------------------0+
            0   |     next[7:0]        |
                +7------------1+----0--+
            1   |        type  |next[8]|
                +--------------+-------+
            2   |        data          |
            ... |                      |
                +----------------------+

        :param datatype: Data type, see DATA_TYPES above
        :param data: data blob
        :returns: data item with header
        """
        item = bytes()
        nextitem = self.offset + 2 + len(data)
        if nextitem > self.slot_len:
            raise ValueError(f"ECC slot capacity exceeded: {nextitem} bytes, capacity {self.slot_len}")
        item += bytes([nextitem & 0xff])
        item += bytes([((nextitem >> 8) & 1) | datatype << 1])
        item += self.protocol.fwdriver._tobytes(data)
        return item

    def add_provinfo_item(self, datatype, data):
        """
        Add provisioning info object to ecc blob.

        :param type: Type of data
        :param data: Data blob
        """
        if not self.blob:
            # we ares starting on a new blob
            self.slot_len = len(self.protocol.ecc_read_slot(self.slot))
            self.offset = 0
            self.blob = bytes()

        self.blob += self.build_item(datatype, data)
        self.offset = len(self.blob)

    def write_provinfo_items(self):
        """
        Write provisioning info to ECC slot
        """
        # FIXME. Let this take list of tuples same as read_provinfo() returns
        if not self.blob:
            raise ValueError("Nothing to write to ECC slot")

        if len(self.blob) <= self.slot_len - 2:
            # Mark end of data if room in slot
            self.blob += bytes([0, 0])
        rval = self.protocol.ecc_write_slot(self.slot, self.blob)
        self.blob = None
        self.offset = 0
        return rval

    def create_write_provinfo(self, items):
        """
        Convenience function: create and write provisioning info block in one go

        :param items: List of (datatype, data) tuples to write
        """
        for item in items:
            self.add_provinfo_item(item[0], item[1])
        self.write_provinfo_items()

    def read_provinfo(self):
        """
        Read existing provisioning info from ECC.

        :return: list of (datatype, data) tuples
        """
        blob = self.protocol.ecc_read_slot(self.slot)
        offset = 0
        rval = list()
        while offset < len(blob) - 2:
            datatype = blob[offset + 1] >> 1
            if datatype == self.EMPTY:
                break
            nextoffset = blob[offset] | (blob[offset + 1] & 1) << 8
            size = nextoffset - offset - 2
            if size <= 0:
                self.logger.error("ECC data item type %d has negative or zero size: %d", datatype, size)
                break

            data = blob[offset + 2: nextoffset]
            rval.append((datatype, data))
            self.logger.debug("type %d size %4d; %s", datatype, len(data), data)
            offset = nextoffset

        return rval
