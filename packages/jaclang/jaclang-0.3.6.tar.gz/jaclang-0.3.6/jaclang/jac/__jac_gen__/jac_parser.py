# The file was automatically generated by Lark v1.1.8
__version__ = "1.1.8"

#
#
#   Lark Stand-alone Generator Tool
# ----------------------------------
# Generates a stand-alone LALR(1) parser
#
# Git:    https://github.com/erezsh/lark
# Author: Erez Shinan (erezshin@gmail.com)
#
#
#    >>> LICENSE
#
#    This tool and its generated code use a separate license from Lark,
#    and are subject to the terms of the Mozilla Public License, v. 2.0.
#    If a copy of the MPL was not distributed with this
#    file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
#    If you wish to purchase a commercial license for this tool and its
#    generated code, you may contact me via email or otherwise.
#
#    If MPL2 is incompatible with your free or open-source project,
#    contact me and we'll work it out.
#
#

from copy import deepcopy
from abc import ABC, abstractmethod
from types import ModuleType
from typing import (
    TypeVar,
    Generic,
    Type,
    Tuple,
    List,
    Dict,
    Iterator,
    Collection,
    Callable,
    Optional,
    FrozenSet,
    Any,
    Union,
    Iterable,
    IO,
    TYPE_CHECKING,
    overload,
    Sequence,
    Pattern as REPattern,
    ClassVar,
    Set,
    Mapping,
)




class LarkError(Exception):
    pass


class ConfigurationError(LarkError, ValueError):
    pass


def assert_config(value, options: Collection, msg="Got %r, expected one of %s"):
    if value not in options:
        raise ConfigurationError(msg % (value, options))


class GrammarError(LarkError):
    pass


class ParseError(LarkError):
    pass


class LexError(LarkError):
    pass


T = TypeVar("T")


class UnexpectedInput(LarkError):
    #--

    line: int
    column: int
    pos_in_stream = None
    state: Any
    _terminals_by_name = None
    interactive_parser: "InteractiveParser"

    def get_context(self, text: str, span: int = 40) -> str:
        #--
        assert self.pos_in_stream is not None, self
        pos = self.pos_in_stream
        start = max(pos - span, 0)
        end = pos + span
        if not isinstance(text, bytes):
            before = text[start:pos].rsplit("\n", 1)[-1]
            after = text[pos:end].split("\n", 1)[0]
            return before + after + "\n" + " " * len(before.expandtabs()) + "^\n"
        else:
            before = text[start:pos].rsplit(b"\n", 1)[-1]
            after = text[pos:end].split(b"\n", 1)[0]
            return (
                before + after + b"\n" + b" " * len(before.expandtabs()) + b"^\n"
            ).decode("ascii", "backslashreplace")

    def match_examples(
        self,
        parse_fn: "Callable[[str], Tree]",
        examples: Union[Mapping[T, Iterable[str]], Iterable[Tuple[T, Iterable[str]]]],
        token_type_match_fallback: bool = False,
        use_accepts: bool = True,
    ) -> Optional[T]:
        #--
        assert self.state is not None, "Not supported for this exception"

        if isinstance(examples, Mapping):
            examples = examples.items()

        candidate = (None, False)
        for i, (label, example) in enumerate(examples):
            assert not isinstance(example, str), "Expecting a list"

            for j, malformed in enumerate(example):
                try:
                    parse_fn(malformed)
                except UnexpectedInput as ut:
                    if ut.state == self.state:
                        if (
                            use_accepts
                            and isinstance(self, UnexpectedToken)
                            and isinstance(ut, UnexpectedToken)
                            and ut.accepts != self.accepts
                        ):
                            logger.debug(
                                "Different accepts with same state[%d]: %s != %s at example [%s][%s]"
                                % (self.state, self.accepts, ut.accepts, i, j)
                            )
                            continue
                        if isinstance(
                            self, (UnexpectedToken, UnexpectedEOF)
                        ) and isinstance(ut, (UnexpectedToken, UnexpectedEOF)):
                            if ut.token == self.token:  ##

                                logger.debug("Exact Match at example [%s][%s]" % (i, j))
                                return label

                            if token_type_match_fallback:
                                ##

                                if (ut.token.type == self.token.type) and not candidate[
                                    -1
                                ]:
                                    logger.debug(
                                        "Token Type Fallback at example [%s][%s]"
                                        % (i, j)
                                    )
                                    candidate = label, True

                        if candidate[0] is None:
                            logger.debug(
                                "Same State match at example [%s][%s]" % (i, j)
                            )
                            candidate = label, False

        return candidate[0]

    def _format_expected(self, expected):
        if self._terminals_by_name:
            d = self._terminals_by_name
            expected = [
                d[t_name].user_repr() if t_name in d else t_name for t_name in expected
            ]
        return "Expected one of: \n\t* %s\n" % "\n\t* ".join(expected)


class UnexpectedEOF(ParseError, UnexpectedInput):
    #--

    expected: "List[Token]"

    def __init__(self, expected, state=None, terminals_by_name=None):
        super(UnexpectedEOF, self).__init__()

        self.expected = expected
        self.state = state
        from .lexer import Token

        self.token = Token("<EOF>", "")  ##

        self.pos_in_stream = -1
        self.line = -1
        self.column = -1
        self._terminals_by_name = terminals_by_name

    def __str__(self):
        message = "Unexpected end-of-input. "
        message += self._format_expected(self.expected)
        return message


class UnexpectedCharacters(LexError, UnexpectedInput):
    #--

    allowed: Set[str]
    considered_tokens: Set[Any]

    def __init__(
        self,
        seq,
        lex_pos,
        line,
        column,
        allowed=None,
        considered_tokens=None,
        state=None,
        token_history=None,
        terminals_by_name=None,
        considered_rules=None,
    ):
        super(UnexpectedCharacters, self).__init__()

        ##

        self.line = line
        self.column = column
        self.pos_in_stream = lex_pos
        self.state = state
        self._terminals_by_name = terminals_by_name

        self.allowed = allowed
        self.considered_tokens = considered_tokens
        self.considered_rules = considered_rules
        self.token_history = token_history

        if isinstance(seq, bytes):
            self.char = seq[lex_pos : lex_pos + 1].decode("ascii", "backslashreplace")
        else:
            self.char = seq[lex_pos]
        self._context = self.get_context(seq)

    def __str__(self):
        message = (
            "No terminal matches '%s' in the current parser context, at line %d col %d"
            % (self.char, self.line, self.column)
        )
        message += "\n\n" + self._context
        if self.allowed:
            message += self._format_expected(self.allowed)
        if self.token_history:
            message += "\nPrevious tokens: %s\n" % ", ".join(
                repr(t) for t in self.token_history
            )
        return message


class UnexpectedToken(ParseError, UnexpectedInput):
    #--

    expected: Set[str]
    considered_rules: Set[str]

    def __init__(
        self,
        token,
        expected,
        considered_rules=None,
        state=None,
        interactive_parser=None,
        terminals_by_name=None,
        token_history=None,
    ):
        super(UnexpectedToken, self).__init__()

        ##

        self.line = getattr(token, "line", "?")
        self.column = getattr(token, "column", "?")
        self.pos_in_stream = getattr(token, "start_pos", None)
        self.state = state

        self.token = token
        self.expected = expected  ##

        self._accepts = NO_VALUE
        self.considered_rules = considered_rules
        self.interactive_parser = interactive_parser
        self._terminals_by_name = terminals_by_name
        self.token_history = token_history

    @property
    def accepts(self) -> Set[str]:
        if self._accepts is NO_VALUE:
            self._accepts = (
                self.interactive_parser and self.interactive_parser.accepts()
            )
        return self._accepts

    def __str__(self):
        message = "Unexpected token %r at line %s, column %s.\n%s" % (
            self.token,
            self.line,
            self.column,
            self._format_expected(self.accepts or self.expected),
        )
        if self.token_history:
            message += "Previous tokens: %r\n" % self.token_history

        return message


class VisitError(LarkError):
    #--

    obj: "Union[Tree, Token]"
    orig_exc: Exception

    def __init__(self, rule, obj, orig_exc):
        message = 'Error trying to process rule "%s":\n\n%s' % (rule, orig_exc)
        super(VisitError, self).__init__(message)

        self.rule = rule
        self.obj = obj
        self.orig_exc = orig_exc


class MissingVariableError(LarkError):
    pass



import sys, re
import logging

logger: logging.Logger = logging.getLogger("lark")
logger.addHandler(logging.StreamHandler())
##

##

logger.setLevel(logging.CRITICAL)


NO_VALUE = object()

T = TypeVar("T")


def classify(
    seq: Iterable, key: Optional[Callable] = None, value: Optional[Callable] = None
) -> Dict:
    d: Dict[Any, Any] = {}
    for item in seq:
        k = key(item) if (key is not None) else item
        v = value(item) if (value is not None) else item
        try:
            d[k].append(v)
        except KeyError:
            d[k] = [v]
    return d


def _deserialize(data: Any, namespace: Dict[str, Any], memo: Dict) -> Any:
    if isinstance(data, dict):
        if "__type__" in data:  ##

            class_ = namespace[data["__type__"]]
            return class_.deserialize(data, memo)
        elif "@" in data:
            return memo[data["@"]]
        return {
            key: _deserialize(value, namespace, memo) for key, value in data.items()
        }
    elif isinstance(data, list):
        return [_deserialize(value, namespace, memo) for value in data]
    return data


_T = TypeVar("_T", bound="Serialize")


class Serialize:
    #--

    def memo_serialize(self, types_to_memoize: List) -> Any:
        memo = SerializeMemoizer(types_to_memoize)
        return self.serialize(memo), memo.serialize()

    def serialize(self, memo=None) -> Dict[str, Any]:
        if memo and memo.in_types(self):
            return {"@": memo.memoized.get(self)}

        fields = getattr(self, "__serialize_fields__")
        res = {f: _serialize(getattr(self, f), memo) for f in fields}
        res["__type__"] = type(self).__name__
        if hasattr(self, "_serialize"):
            self._serialize(res, memo)  ##

        return res

    @classmethod
    def deserialize(cls: Type[_T], data: Dict[str, Any], memo: Dict[int, Any]) -> _T:
        namespace = getattr(cls, "__serialize_namespace__", [])
        namespace = {c.__name__: c for c in namespace}

        fields = getattr(cls, "__serialize_fields__")

        if "@" in data:
            return memo[data["@"]]

        inst = cls.__new__(cls)
        for f in fields:
            try:
                setattr(inst, f, _deserialize(data[f], namespace, memo))
            except KeyError as e:
                raise KeyError("Cannot find key for class", cls, e)

        if hasattr(inst, "_deserialize"):
            inst._deserialize()  ##


        return inst


class SerializeMemoizer(Serialize):
    #--

    __serialize_fields__ = ("memoized",)

    def __init__(self, types_to_memoize: List) -> None:
        self.types_to_memoize = tuple(types_to_memoize)
        self.memoized = Enumerator()

    def in_types(self, value: Serialize) -> bool:
        return isinstance(value, self.types_to_memoize)

    def serialize(self) -> Dict[int, Any]:  ##

        return _serialize(self.memoized.reversed(), None)

    @classmethod
    def deserialize(cls, data: Dict[int, Any], namespace: Dict[str, Any], memo: Dict[Any, Any]) -> Dict[int, Any]:  ##

        return _deserialize(data, namespace, memo)


try:
    import regex

    _has_regex = True
except ImportError:
    _has_regex = False

if sys.version_info >= (3, 11):
    import re._parser as sre_parse
    import re._constants as sre_constants
else:
    import sre_parse
    import sre_constants

categ_pattern = re.compile(r"\\p{[A-Za-z_]+}")


def get_regexp_width(expr: str) -> Union[Tuple[int, int], List[int]]:
    if _has_regex:
        ##

        ##

        ##

        regexp_final = re.sub(categ_pattern, "A", expr)
    else:
        if re.search(categ_pattern, expr):
            raise ImportError(
                "`regex` module must be installed in order to use Unicode categories.",
                expr,
            )
        regexp_final = expr
    try:
        ##

        return [int(x) for x in sre_parse.parse(regexp_final).getwidth()]  ##

    except sre_constants.error:
        if not _has_regex:
            raise ValueError(expr)
        else:
            ##

            ##

            c = regex.compile(regexp_final)
            if c.match("") is None:
                ##

                return 1, int(sre_constants.MAXREPEAT)
            else:
                return 0, int(sre_constants.MAXREPEAT)



from collections import OrderedDict


class Meta:
    empty: bool
    line: int
    column: int
    start_pos: int
    end_line: int
    end_column: int
    end_pos: int
    orig_expansion: "List[TerminalDef]"
    match_tree: bool

    def __init__(self):
        self.empty = True


_Leaf_T = TypeVar("_Leaf_T")
Branch = Union[_Leaf_T, "Tree[_Leaf_T]"]


class Tree(Generic[_Leaf_T]):
    #--

    data: str
    children: "List[Branch[_Leaf_T]]"

    def __init__(
        self, data: str, children: "List[Branch[_Leaf_T]]", meta: Optional[Meta] = None
    ) -> None:
        self.data = data
        self.children = children
        self._meta = meta

    @property
    def meta(self) -> Meta:
        if self._meta is None:
            self._meta = Meta()
        return self._meta

    def __repr__(self):
        return "Tree(%r, %r)" % (self.data, self.children)

    def _pretty_label(self):
        return self.data

    def _pretty(self, level, indent_str):
        yield f"{indent_str*level}{self._pretty_label()}"
        if len(self.children) == 1 and not isinstance(self.children[0], Tree):
            yield f"\t{self.children[0]}\n"
        else:
            yield "\n"
            for n in self.children:
                if isinstance(n, Tree):
                    yield from n._pretty(level + 1, indent_str)
                else:
                    yield f"{indent_str*(level+1)}{n}\n"

    def pretty(self, indent_str: str = "  ") -> str:
        #--
        return "".join(self._pretty(0, indent_str))

    def __rich__(self, parent: Optional["rich.tree.Tree"] = None) -> "rich.tree.Tree":
        #--
        return self._rich(parent)

    def _rich(self, parent):
        if parent:
            tree = parent.add(f"[bold]{self.data}[/bold]")
        else:
            import rich.tree

            tree = rich.tree.Tree(self.data)

        for c in self.children:
            if isinstance(c, Tree):
                c._rich(tree)
            else:
                tree.add(f"[green]{c}[/green]")

        return tree

    def __eq__(self, other):
        try:
            return self.data == other.data and self.children == other.children
        except AttributeError:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self) -> int:
        return hash((self.data, tuple(self.children)))

    def iter_subtrees(self) -> "Iterator[Tree[_Leaf_T]]":
        #--
        queue = [self]
        subtrees = OrderedDict()
        for subtree in queue:
            subtrees[id(subtree)] = subtree
            ##

            queue += [
                c
                for c in reversed(subtree.children)  ##

                if isinstance(c, Tree) and id(c) not in subtrees
            ]

        del queue
        return reversed(list(subtrees.values()))

    def iter_subtrees_topdown(self):
        #--
        stack = [self]
        stack_append = stack.append
        stack_pop = stack.pop
        while stack:
            node = stack_pop()
            if not isinstance(node, Tree):
                continue
            yield node
            for child in reversed(node.children):
                stack_append(child)

    def find_pred(
        self, pred: "Callable[[Tree[_Leaf_T]], bool]"
    ) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return filter(pred, self.iter_subtrees())

    def find_data(self, data: str) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return self.find_pred(lambda t: t.data == data)


from functools import wraps, update_wrapper
from inspect import getmembers, getmro

_Return_T = TypeVar("_Return_T")
_Return_V = TypeVar("_Return_V")
_Leaf_T = TypeVar("_Leaf_T")
_Leaf_U = TypeVar("_Leaf_U")
_R = TypeVar("_R")
_FUNC = Callable[..., _Return_T]
_DECORATED = Union[_FUNC, type]


class _DiscardType:
    #--

    def __repr__(self):
        return "lark.visitors.Discard"


Discard = _DiscardType()

##



class _Decoratable:
    #--

    @classmethod
    def _apply_v_args(cls, visit_wrapper):
        mro = getmro(cls)
        assert mro[0] is cls
        libmembers = {name for _cls in mro[1:] for name, _ in getmembers(_cls)}
        for name, value in getmembers(cls):
            ##

            if name.startswith("_") or (
                name in libmembers and name not in cls.__dict__
            ):
                continue
            if not callable(value):
                continue

            ##

            if isinstance(cls.__dict__[name], _VArgsWrapper):
                continue

            setattr(cls, name, _VArgsWrapper(cls.__dict__[name], visit_wrapper))
        return cls

    def __class_getitem__(cls, _):
        return cls


class Transformer(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    __visit_tokens__ = True  ##


    def __init__(self, visit_tokens: bool = True) -> None:
        self.__visit_tokens__ = visit_tokens

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            try:
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    return f.visit_wrapper(f, tree.data, children, tree.meta)
                else:
                    return f(children)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(tree.data, tree, e)

    def _call_userfunc_token(self, token):
        try:
            f = getattr(self, token.type)
        except AttributeError:
            return self.__default_token__(token)
        else:
            try:
                return f(token)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(token.type, token, e)

    def _transform_children(self, children):
        for c in children:
            if isinstance(c, Tree):
                res = self._transform_tree(c)
            elif self.__visit_tokens__ and isinstance(c, Token):
                res = self._call_userfunc_token(c)
            else:
                res = c

            if res is not Discard:
                yield res

    def _transform_tree(self, tree):
        children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree, children)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        #--
        return self._transform_tree(tree)

    def __mul__(
        self: "Transformer[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V,]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        #--
        return TransformerChain(self, other)

    def __default__(self, data, children, meta):
        #--
        return Tree(data, children, meta)

    def __default_token__(self, token):
        #--
        return token


def merge_transformers(base_transformer=None, **transformers_to_merge):
    #--
    if base_transformer is None:
        base_transformer = Transformer()
    for prefix, transformer in transformers_to_merge.items():
        for method_name in dir(transformer):
            method = getattr(transformer, method_name)
            if not callable(method):
                continue
            if method_name.startswith("_") or method_name == "transform":
                continue
            prefixed_method = prefix + "__" + method_name
            if hasattr(base_transformer, prefixed_method):
                raise AttributeError(
                    "Cannot merge: method '%s' appears more than once" % prefixed_method
                )

            setattr(base_transformer, prefixed_method, method)

    return base_transformer


class InlineTransformer(Transformer):  ##

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            return f(*children)


class TransformerChain(Generic[_Leaf_T, _Return_T]):
    transformers: "Tuple[Union[Transformer, TransformerChain], ...]"

    def __init__(self, *transformers: "Union[Transformer, TransformerChain]") -> None:
        self.transformers = transformers

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for t in self.transformers:
            tree = t.transform(tree)
        return cast(_Return_T, tree)

    def __mul__(
        self: "TransformerChain[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        return TransformerChain(*self.transformers + (other,))


class Transformer_InPlace(Transformer[_Leaf_T, _Return_T]):
    #--

    def _transform_tree(self, tree):  ##

        return self._call_userfunc(tree)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for subtree in tree.iter_subtrees():
            subtree.children = list(self._transform_children(subtree.children))

        return self._transform_tree(tree)


class Transformer_NonRecursive(Transformer[_Leaf_T, _Return_T]):
    #--

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        rev_postfix = []
        q: List[Branch[_Leaf_T]] = [tree]
        while q:
            t = q.pop()
            rev_postfix.append(t)
            if isinstance(t, Tree):
                q += t.children

        ##

        stack: List = []
        for x in reversed(rev_postfix):
            if isinstance(x, Tree):
                size = len(x.children)
                if size:
                    args = stack[-size:]
                    del stack[-size:]
                else:
                    args = []

                res = self._call_userfunc(x, args)
                if res is not Discard:
                    stack.append(res)

            elif self.__visit_tokens__ and isinstance(x, Token):
                res = self._call_userfunc_token(x)
                if res is not Discard:
                    stack.append(res)
            else:
                stack.append(x)

        (result,) = stack  ##

        ##

        ##

        ##

        return cast(_Return_T, result)


class Transformer_InPlaceRecursive(Transformer):
    #--

    def _transform_tree(self, tree):
        tree.children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree)


##



class VisitorBase:
    def _call_userfunc(self, tree):
        return getattr(self, tree.data, self.__default__)(tree)

    def __default__(self, tree):
        #--
        return tree

    def __class_getitem__(cls, _):
        return cls


class Visitor(VisitorBase, ABC, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees():
            self._call_userfunc(subtree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees_topdown():
            self._call_userfunc(subtree)
        return tree


class Visitor_Recursive(VisitorBase, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for child in tree.children:
            if isinstance(child, Tree):
                self.visit(child)

        self._call_userfunc(tree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        self._call_userfunc(tree)

        for child in tree.children:
            if isinstance(child, Tree):
                self.visit_topdown(child)

        return tree


class Interpreter(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        ##

        ##

        return self._visit_tree(tree)

    def _visit_tree(self, tree: Tree[_Leaf_T]):
        f = getattr(self, tree.data)
        wrapper = getattr(f, "visit_wrapper", None)
        if wrapper is not None:
            return f.visit_wrapper(f, tree.data, tree.children, tree.meta)
        else:
            return f(tree)

    def visit_children(self, tree: Tree[_Leaf_T]) -> List:
        return [
            self._visit_tree(child) if isinstance(child, Tree) else child
            for child in tree.children
        ]

    def __getattr__(self, name):
        return self.__default__

    def __default__(self, tree):
        return self.visit_children(tree)


_InterMethod = Callable[[Type[Interpreter], _Return_T], _R]


def visit_children_decor(func: _InterMethod) -> _InterMethod:
    #--

    @wraps(func)
    def inner(cls, tree):
        values = cls.visit_children(tree)
        return func(cls, values)

    return inner


##



def _apply_v_args(obj, visit_wrapper):
    try:
        _apply = obj._apply_v_args
    except AttributeError:
        return _VArgsWrapper(obj, visit_wrapper)
    else:
        return _apply(visit_wrapper)


class _VArgsWrapper:
    #--

    base_func: Callable

    def __init__(
        self, func: Callable, visit_wrapper: Callable[[Callable, str, list, Any], Any]
    ):
        if isinstance(func, _VArgsWrapper):
            func = func.base_func
        ##

        self.base_func = func  ##

        self.visit_wrapper = visit_wrapper
        update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        return self.base_func(*args, **kwargs)

    def __get__(self, instance, owner=None):
        try:
            ##

            ##

            g = type(self.base_func).__get__
        except AttributeError:
            return self
        else:
            return _VArgsWrapper(g(self.base_func, instance, owner), self.visit_wrapper)

    def __set_name__(self, owner, name):
        try:
            f = type(self.base_func).__set_name__
        except AttributeError:
            return
        else:
            f(self.base_func, owner, name)


def _vargs_inline(f, _data, children, _meta):
    return f(*children)


def _vargs_meta_inline(f, _data, children, meta):
    return f(meta, *children)


def _vargs_meta(f, _data, children, meta):
    return f(meta, children)


def _vargs_tree(f, data, children, meta):
    return f(Tree(data, children, meta))


def v_args(
    inline: bool = False,
    meta: bool = False,
    tree: bool = False,
    wrapper: Optional[Callable] = None,
) -> Callable[[_DECORATED], _DECORATED]:
    #--
    if tree and (meta or inline):
        raise ValueError(
            "Visitor functions cannot combine 'tree' with 'meta' or 'inline'."
        )

    func = None
    if meta:
        if inline:
            func = _vargs_meta_inline
        else:
            func = _vargs_meta
    elif inline:
        func = _vargs_inline
    elif tree:
        func = _vargs_tree

    if wrapper is not None:
        if func is not None:
            raise ValueError(
                "Cannot use 'wrapper' along with 'tree', 'meta' or 'inline'."
            )
        func = wrapper

    def _visitor_args_dec(obj):
        return _apply_v_args(obj, func)

    return _visitor_args_dec



TOKEN_DEFAULT_PRIORITY = 0


class Symbol(Serialize):
    __slots__ = ("name",)

    name: str
    is_term: ClassVar[bool] = NotImplemented

    def __init__(self, name: str) -> None:
        self.name = name

    def __eq__(self, other):
        assert isinstance(other, Symbol), other
        return self.is_term == other.is_term and self.name == other.name

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.name)

    def __repr__(self):
        return "%s(%r)" % (type(self).__name__, self.name)

    fullrepr = property(__repr__)

    def renamed(self, f):
        return type(self)(f(self.name))


class Terminal(Symbol):
    __serialize_fields__ = "name", "filter_out"

    is_term: ClassVar[bool] = True

    def __init__(self, name, filter_out=False):
        self.name = name
        self.filter_out = filter_out

    @property
    def fullrepr(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.filter_out)

    def renamed(self, f):
        return type(self)(f(self.name), self.filter_out)


class NonTerminal(Symbol):
    __serialize_fields__ = ("name",)

    is_term: ClassVar[bool] = False


class RuleOptions(Serialize):
    __serialize_fields__ = (
        "keep_all_tokens",
        "expand1",
        "priority",
        "template_source",
        "empty_indices",
    )

    keep_all_tokens: bool
    expand1: bool
    priority: Optional[int]
    template_source: Optional[str]
    empty_indices: Tuple[bool, ...]

    def __init__(
        self,
        keep_all_tokens: bool = False,
        expand1: bool = False,
        priority: Optional[int] = None,
        template_source: Optional[str] = None,
        empty_indices: Tuple[bool, ...] = (),
    ) -> None:
        self.keep_all_tokens = keep_all_tokens
        self.expand1 = expand1
        self.priority = priority
        self.template_source = template_source
        self.empty_indices = empty_indices

    def __repr__(self):
        return "RuleOptions(%r, %r, %r, %r)" % (
            self.keep_all_tokens,
            self.expand1,
            self.priority,
            self.template_source,
        )


class Rule(Serialize):
    #--

    __slots__ = ("origin", "expansion", "alias", "options", "order", "_hash")

    __serialize_fields__ = "origin", "expansion", "order", "alias", "options"
    __serialize_namespace__ = Terminal, NonTerminal, RuleOptions

    origin: NonTerminal
    expansion: Sequence[Symbol]
    order: int
    alias: Optional[str]
    options: RuleOptions
    _hash: int

    def __init__(
        self,
        origin: NonTerminal,
        expansion: Sequence[Symbol],
        order: int = 0,
        alias: Optional[str] = None,
        options: Optional[RuleOptions] = None,
    ):
        self.origin = origin
        self.expansion = expansion
        self.alias = alias
        self.order = order
        self.options = options or RuleOptions()
        self._hash = hash((self.origin, tuple(self.expansion)))

    def _deserialize(self):
        self._hash = hash((self.origin, tuple(self.expansion)))

    def __str__(self):
        return "<%s : %s>" % (
            self.origin.name,
            " ".join(x.name for x in self.expansion),
        )

    def __repr__(self):
        return "Rule(%r, %r, %r, %r)" % (
            self.origin,
            self.expansion,
            self.alias,
            self.options,
        )

    def __hash__(self):
        return self._hash

    def __eq__(self, other):
        if not isinstance(other, Rule):
            return False
        return self.origin == other.origin and self.expansion == other.expansion



from copy import copy

try:  ##

    has_interegular = bool(interegular)
except NameError:
    has_interegular = False


class Pattern(Serialize, ABC):
    #--

    value: str
    flags: Collection[str]
    raw: Optional[str]
    type: ClassVar[str]

    def __init__(
        self, value: str, flags: Collection[str] = (), raw: Optional[str] = None
    ) -> None:
        self.value = value
        self.flags = frozenset(flags)
        self.raw = raw

    def __repr__(self):
        return repr(self.to_regexp())

    ##

    def __hash__(self):
        return hash((type(self), self.value, self.flags))

    def __eq__(self, other):
        return (
            type(self) == type(other)
            and self.value == other.value
            and self.flags == other.flags
        )

    @abstractmethod
    def to_regexp(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def min_width(self) -> int:
        raise NotImplementedError()

    @property
    @abstractmethod
    def max_width(self) -> int:
        raise NotImplementedError()

    def _get_flags(self, value):
        for f in self.flags:
            value = "(?%s:%s)" % (f, value)
        return value


class PatternStr(Pattern):
    __serialize_fields__ = "value", "flags", "raw"

    type: ClassVar[str] = "str"

    def to_regexp(self) -> str:
        return self._get_flags(re.escape(self.value))

    @property
    def min_width(self) -> int:
        return len(self.value)

    @property
    def max_width(self) -> int:
        return len(self.value)


class PatternRE(Pattern):
    __serialize_fields__ = "value", "flags", "raw", "_width"

    type: ClassVar[str] = "re"

    def to_regexp(self) -> str:
        return self._get_flags(self.value)

    _width = None

    def _get_width(self):
        if self._width is None:
            self._width = get_regexp_width(self.to_regexp())
        return self._width

    @property
    def min_width(self) -> int:
        return self._get_width()[0]

    @property
    def max_width(self) -> int:
        return self._get_width()[1]


class TerminalDef(Serialize):
    #--
    __serialize_fields__ = "name", "pattern", "priority"
    __serialize_namespace__ = PatternStr, PatternRE

    name: str
    pattern: Pattern
    priority: int

    def __init__(
        self, name: str, pattern: Pattern, priority: int = TOKEN_DEFAULT_PRIORITY
    ) -> None:
        assert isinstance(pattern, Pattern), pattern
        self.name = name
        self.pattern = pattern
        self.priority = priority

    def __repr__(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.pattern)

    def user_repr(self) -> str:
        if self.name.startswith("__"):  ##

            return self.pattern.raw or self.name
        else:
            return self.name


_T = TypeVar("_T", bound="Token")


class Token(str):
    #--

    __slots__ = (
        "type",
        "start_pos",
        "value",
        "line",
        "column",
        "end_line",
        "end_column",
        "end_pos",
    )

    __match_args__ = ("type", "value")

    type: str
    start_pos: Optional[int]
    value: Any
    line: Optional[int]
    column: Optional[int]
    end_line: Optional[int]
    end_column: Optional[int]
    end_pos: Optional[int]

    @overload
    def __new__(
        cls,
        type: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    @overload
    def __new__(
        cls,
        type_: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    def __new__(cls, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return cls._future_new(*args, **kwargs)

    @classmethod
    def _future_new(
        cls,
        type,
        value,
        start_pos=None,
        line=None,
        column=None,
        end_line=None,
        end_column=None,
        end_pos=None,
    ):
        inst = super(Token, cls).__new__(cls, value)

        inst.type = type
        inst.start_pos = start_pos
        inst.value = value
        inst.line = line
        inst.column = column
        inst.end_line = end_line
        inst.end_column = end_column
        inst.end_pos = end_pos
        return inst

    @overload
    def update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    @overload
    def update(
        self, type_: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    def update(self, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return self._future_update(*args, **kwargs)

    def _future_update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        return Token.new_borrow_pos(
            type if type is not None else self.type,
            value if value is not None else self.value,
            self,
        )

    @classmethod
    def new_borrow_pos(cls: Type[_T], type_: str, value: Any, borrow_t: "Token") -> _T:
        return cls(
            type_,
            value,
            borrow_t.start_pos,
            borrow_t.line,
            borrow_t.column,
            borrow_t.end_line,
            borrow_t.end_column,
            borrow_t.end_pos,
        )

    def __reduce__(self):
        return (
            self.__class__,
            (self.type, self.value, self.start_pos, self.line, self.column),
        )

    def __repr__(self):
        return "Token(%r, %r)" % (self.type, self.value)

    def __deepcopy__(self, memo):
        return Token(self.type, self.value, self.start_pos, self.line, self.column)

    def __eq__(self, other):
        if isinstance(other, Token) and self.type != other.type:
            return False

        return str.__eq__(self, other)

    __hash__ = str.__hash__


class LineCounter:
    #--

    __slots__ = "char_pos", "line", "column", "line_start_pos", "newline_char"

    def __init__(self, newline_char):
        self.newline_char = newline_char
        self.char_pos = 0
        self.line = 1
        self.column = 1
        self.line_start_pos = 0

    def __eq__(self, other):
        if not isinstance(other, LineCounter):
            return NotImplemented

        return (
            self.char_pos == other.char_pos and self.newline_char == other.newline_char
        )

    def feed(self, token: Token, test_newline=True):
        #--
        if test_newline:
            newlines = token.count(self.newline_char)
            if newlines:
                self.line += newlines
                self.line_start_pos = (
                    self.char_pos + token.rindex(self.newline_char) + 1
                )

        self.char_pos += len(token)
        self.column = self.char_pos - self.line_start_pos + 1


class UnlessCallback:
    def __init__(self, scanner):
        self.scanner = scanner

    def __call__(self, t):
        res = self.scanner.match(t.value, 0)
        if res:
            _value, t.type = res
        return t


class CallChain:
    def __init__(self, callback1, callback2, cond):
        self.callback1 = callback1
        self.callback2 = callback2
        self.cond = cond

    def __call__(self, t):
        t2 = self.callback1(t)
        return self.callback2(t) if self.cond(t2) else t2


def _get_match(re_, regexp, s, flags):
    m = re_.match(regexp, s, flags)
    if m:
        return m.group(0)


def _create_unless(terminals, g_regex_flags, re_, use_bytes):
    tokens_by_type = classify(terminals, lambda t: type(t.pattern))
    assert len(tokens_by_type) <= 2, tokens_by_type.keys()
    embedded_strs = set()
    callback = {}
    for retok in tokens_by_type.get(PatternRE, []):
        unless = []
        for strtok in tokens_by_type.get(PatternStr, []):
            if strtok.priority != retok.priority:
                continue
            s = strtok.pattern.value
            if s == _get_match(re_, retok.pattern.to_regexp(), s, g_regex_flags):
                unless.append(strtok)
                if strtok.pattern.flags <= retok.pattern.flags:
                    embedded_strs.add(strtok)
        if unless:
            callback[retok.name] = UnlessCallback(
                Scanner(
                    unless, g_regex_flags, re_, match_whole=True, use_bytes=use_bytes
                )
            )

    new_terminals = [t for t in terminals if t not in embedded_strs]
    return new_terminals, callback


class Scanner:
    def __init__(self, terminals, g_regex_flags, re_, use_bytes, match_whole=False):
        self.terminals = terminals
        self.g_regex_flags = g_regex_flags
        self.re_ = re_
        self.use_bytes = use_bytes
        self.match_whole = match_whole

        self.allowed_types = {t.name for t in self.terminals}

        self._mres = self._build_mres(terminals, len(terminals))

    def _build_mres(self, terminals, max_size):
        ##

        ##

        ##

        postfix = "$" if self.match_whole else ""
        mres = []
        while terminals:
            pattern = "|".join(
                "(?P<%s>%s)" % (t.name, t.pattern.to_regexp() + postfix)
                for t in terminals[:max_size]
            )
            if self.use_bytes:
                pattern = pattern.encode("latin-1")
            try:
                mre = self.re_.compile(pattern, self.g_regex_flags)
            except AssertionError:  ##

                return self._build_mres(terminals, max_size // 2)

            mres.append(mre)
            terminals = terminals[max_size:]
        return mres

    def match(self, text, pos):
        for mre in self._mres:
            m = mre.match(text, pos)
            if m:
                return m.group(0), m.lastgroup


def _regexp_has_newline(r: str):
    #--
    return (
        "\n" in r or "\\n" in r or "\\s" in r or "[^" in r or ("(?s" in r and "." in r)
    )


class LexerState:
    #--

    __slots__ = "text", "line_ctr", "last_token"

    text: str
    line_ctr: LineCounter
    last_token: Optional[Token]

    def __init__(
        self,
        text: str,
        line_ctr: Optional[LineCounter] = None,
        last_token: Optional[Token] = None,
    ):
        self.text = text
        self.line_ctr = line_ctr or LineCounter(
            b"\n" if isinstance(text, bytes) else "\n"
        )
        self.last_token = last_token

    def __eq__(self, other):
        if not isinstance(other, LexerState):
            return NotImplemented

        return (
            self.text is other.text
            and self.line_ctr == other.line_ctr
            and self.last_token == other.last_token
        )

    def __copy__(self):
        return type(self)(self.text, copy(self.line_ctr), self.last_token)


class LexerThread:
    #--

    def __init__(self, lexer: "Lexer", lexer_state: LexerState):
        self.lexer = lexer
        self.state = lexer_state

    @classmethod
    def from_text(cls, lexer: "Lexer", text: str) -> "LexerThread":
        return cls(lexer, LexerState(text))

    def lex(self, parser_state):
        return self.lexer.lex(self.state, parser_state)

    def __copy__(self):
        return type(self)(self.lexer, copy(self.state))

    _Token = Token


_Callback = Callable[[Token], Token]


class Lexer(ABC):
    #--

    @abstractmethod
    def lex(self, lexer_state: LexerState, parser_state: Any) -> Iterator[Token]:
        return NotImplemented

    def make_lexer_state(self, text):
        #--
        return LexerState(text)


def _check_regex_collisions(
    terminal_to_regexp: Dict[TerminalDef, str],
    comparator,
    strict_mode,
    max_collisions_to_show=8,
):
    if not comparator:
        comparator = interegular.Comparator.from_regexes(terminal_to_regexp)

    ##

    ##

    max_time = 2 if strict_mode else 0.2

    ##

    if comparator.count_marked_pairs() >= max_collisions_to_show:
        return
    for group in classify(terminal_to_regexp, lambda t: t.priority).values():
        for a, b in comparator.check(group, skip_marked=True):
            assert a.priority == b.priority
            ##

            comparator.mark(a, b)

            ##

            message = f"Collision between Terminals {a.name} and {b.name}. "
            try:
                example = comparator.get_example_overlap(
                    a, b, max_time
                ).format_multiline()
            except ValueError:
                ##

                example = "No example could be found fast enough. However, the collision does still exists"
            if strict_mode:
                raise LexError(f"{message}\n{example}")
            logger.warning(
                "%s The lexer will choose between them arbitrarily.\n%s",
                message,
                example,
            )
            if comparator.count_marked_pairs() >= max_collisions_to_show:
                logger.warning("Found 8 regex collisions, will not check for more.")
                return


class AbstractBasicLexer(Lexer):
    terminals_by_name: Dict[str, TerminalDef]

    @abstractmethod
    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        ...

    @abstractmethod
    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        ...

    def lex(self, state: LexerState, parser_state: Any) -> Iterator[Token]:
        with suppress(EOFError):
            while True:
                yield self.next_token(state, parser_state)


class BasicLexer(AbstractBasicLexer):
    terminals: Collection[TerminalDef]
    ignore_types: FrozenSet[str]
    newline_types: FrozenSet[str]
    user_callbacks: Dict[str, _Callback]
    callback: Dict[str, _Callback]
    re: ModuleType

    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        terminals = list(conf.terminals)
        assert all(isinstance(t, TerminalDef) for t in terminals), terminals

        self.re = conf.re_module

        if not conf.skip_validation:
            ##

            terminal_to_regexp = {}
            for t in terminals:
                regexp = t.pattern.to_regexp()
                try:
                    self.re.compile(regexp, conf.g_regex_flags)
                except self.re.error:
                    raise LexError("Cannot compile token %s: %s" % (t.name, t.pattern))

                if t.pattern.min_width == 0:
                    raise LexError(
                        "Lexer does not allow zero-width terminals. (%s: %s)"
                        % (t.name, t.pattern)
                    )
                if t.pattern.type == "re":
                    terminal_to_regexp[t] = regexp

            if not (set(conf.ignore) <= {t.name for t in terminals}):
                raise LexError(
                    "Ignore terminals are not defined: %s"
                    % (set(conf.ignore) - {t.name for t in terminals})
                )

            if has_interegular:
                _check_regex_collisions(terminal_to_regexp, comparator, conf.strict)
            elif conf.strict:
                raise LexError(
                    "interegular must be installed for strict mode. Use `pip install 'lark[interegular]'`."
                )

        ##

        self.newline_types = frozenset(
            t.name for t in terminals if _regexp_has_newline(t.pattern.to_regexp())
        )
        self.ignore_types = frozenset(conf.ignore)

        terminals.sort(
            key=lambda x: (
                -x.priority,
                -x.pattern.max_width,
                -len(x.pattern.value),
                x.name,
            )
        )
        self.terminals = terminals
        self.user_callbacks = conf.callbacks
        self.g_regex_flags = conf.g_regex_flags
        self.use_bytes = conf.use_bytes
        self.terminals_by_name = conf.terminals_by_name

        self._scanner = None

    def _build_scanner(self):
        terminals, self.callback = _create_unless(
            self.terminals, self.g_regex_flags, self.re, self.use_bytes
        )
        assert all(self.callback.values())

        for type_, f in self.user_callbacks.items():
            if type_ in self.callback:
                ##

                self.callback[type_] = CallChain(
                    self.callback[type_], f, lambda t: t.type == type_
                )
            else:
                self.callback[type_] = f

        self._scanner = Scanner(terminals, self.g_regex_flags, self.re, self.use_bytes)

    @property
    def scanner(self):
        if self._scanner is None:
            self._build_scanner()
        return self._scanner

    def match(self, text, pos):
        return self.scanner.match(text, pos)

    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        line_ctr = lex_state.line_ctr
        while line_ctr.char_pos < len(lex_state.text):
            res = self.match(lex_state.text, line_ctr.char_pos)
            if not res:
                allowed = self.scanner.allowed_types - self.ignore_types
                if not allowed:
                    allowed = {"<END-OF-FILE>"}
                raise UnexpectedCharacters(
                    lex_state.text,
                    line_ctr.char_pos,
                    line_ctr.line,
                    line_ctr.column,
                    allowed=allowed,
                    token_history=lex_state.last_token and [lex_state.last_token],
                    state=parser_state,
                    terminals_by_name=self.terminals_by_name,
                )

            value, type_ = res

            ignored = type_ in self.ignore_types
            t = None
            if not ignored or type_ in self.callback:
                t = Token(
                    type_, value, line_ctr.char_pos, line_ctr.line, line_ctr.column
                )
            line_ctr.feed(value, type_ in self.newline_types)
            if t is not None:
                t.end_line = line_ctr.line
                t.end_column = line_ctr.column
                t.end_pos = line_ctr.char_pos
                if t.type in self.callback:
                    t = self.callback[t.type](t)
                if not ignored:
                    if not isinstance(t, Token):
                        raise LexError(
                            "Callbacks must return a token (returned %r)" % t
                        )
                    lex_state.last_token = t
                    return t

        ##

        raise EOFError(self)


class ContextualLexer(Lexer):
    lexers: Dict[int, AbstractBasicLexer]
    root_lexer: AbstractBasicLexer

    BasicLexer: Type[AbstractBasicLexer] = BasicLexer

    def __init__(
        self,
        conf: "LexerConf",
        states: Dict[int, Collection[str]],
        always_accept: Collection[str] = (),
    ) -> None:
        terminals = list(conf.terminals)
        terminals_by_name = conf.terminals_by_name

        trad_conf = copy(conf)
        trad_conf.terminals = terminals

        if has_interegular and not conf.skip_validation:
            comparator = interegular.Comparator.from_regexes(
                {t: t.pattern.to_regexp() for t in terminals}
            )
        else:
            comparator = None
        lexer_by_tokens: Dict[FrozenSet[str], AbstractBasicLexer] = {}
        self.lexers = {}
        for state, accepts in states.items():
            key = frozenset(accepts)
            try:
                lexer = lexer_by_tokens[key]
            except KeyError:
                accepts = set(accepts) | set(conf.ignore) | set(always_accept)
                lexer_conf = copy(trad_conf)
                lexer_conf.terminals = [
                    terminals_by_name[n] for n in accepts if n in terminals_by_name
                ]
                lexer = self.BasicLexer(lexer_conf, comparator)
                lexer_by_tokens[key] = lexer

            self.lexers[state] = lexer

        assert trad_conf.terminals is terminals
        trad_conf.skip_validation = True  ##

        self.root_lexer = self.BasicLexer(trad_conf, comparator)

    def lex(
        self, lexer_state: LexerState, parser_state: "ParserState"
    ) -> Iterator[Token]:
        try:
            while True:
                lexer = self.lexers[parser_state.position]
                yield lexer.next_token(lexer_state, parser_state)
        except EOFError:
            pass
        except UnexpectedCharacters as e:
            ##

            ##

            try:
                last_token = (
                    lexer_state.last_token
                )  ##

                token = self.root_lexer.next_token(lexer_state, parser_state)
                raise UnexpectedToken(
                    token,
                    e.allowed,
                    state=parser_state,
                    token_history=[last_token],
                    terminals_by_name=self.root_lexer.terminals_by_name,
                )
            except UnexpectedCharacters:
                raise e  ##





_ParserArgType: "TypeAlias" = 'Literal["earley", "lalr", "cyk", "auto"]'
_LexerArgType: "TypeAlias" = 'Union[Literal["auto", "basic", "contextual", "dynamic", "dynamic_complete"], Type[Lexer]]'
_LexerCallback = Callable[[Token], Token]
ParserCallbacks = Dict[str, Callable]


class LexerConf(Serialize):
    __serialize_fields__ = (
        "terminals",
        "ignore",
        "g_regex_flags",
        "use_bytes",
        "lexer_type",
    )
    __serialize_namespace__ = (TerminalDef,)

    terminals: Collection[TerminalDef]
    re_module: ModuleType
    ignore: Collection[str]
    postlex: "Optional[PostLex]"
    callbacks: Dict[str, _LexerCallback]
    g_regex_flags: int
    skip_validation: bool
    use_bytes: bool
    lexer_type: Optional[_LexerArgType]
    strict: bool

    def __init__(
        self,
        terminals: Collection[TerminalDef],
        re_module: ModuleType,
        ignore: Collection[str] = (),
        postlex: "Optional[PostLex]" = None,
        callbacks: Optional[Dict[str, _LexerCallback]] = None,
        g_regex_flags: int = 0,
        skip_validation: bool = False,
        use_bytes: bool = False,
        strict: bool = False,
    ):
        self.terminals = terminals
        self.terminals_by_name = {t.name: t for t in self.terminals}
        assert len(self.terminals) == len(self.terminals_by_name)
        self.ignore = ignore
        self.postlex = postlex
        self.callbacks = callbacks or {}
        self.g_regex_flags = g_regex_flags
        self.re_module = re_module
        self.skip_validation = skip_validation
        self.use_bytes = use_bytes
        self.strict = strict
        self.lexer_type = None

    def _deserialize(self):
        self.terminals_by_name = {t.name: t for t in self.terminals}

    def __deepcopy__(self, memo=None):
        return type(self)(
            deepcopy(self.terminals, memo),
            self.re_module,
            deepcopy(self.ignore, memo),
            deepcopy(self.postlex, memo),
            deepcopy(self.callbacks, memo),
            deepcopy(self.g_regex_flags, memo),
            deepcopy(self.skip_validation, memo),
            deepcopy(self.use_bytes, memo),
        )


class ParserConf(Serialize):
    __serialize_fields__ = "rules", "start", "parser_type"

    rules: List["Rule"]
    callbacks: ParserCallbacks
    start: List[str]
    parser_type: _ParserArgType

    def __init__(
        self, rules: List["Rule"], callbacks: ParserCallbacks, start: List[str]
    ):
        assert isinstance(start, list)
        self.rules = rules
        self.callbacks = callbacks
        self.start = start



from functools import partial, wraps
from itertools import product


class ExpandSingleChild:
    def __init__(self, node_builder):
        self.node_builder = node_builder

    def __call__(self, children):
        if len(children) == 1:
            return children[0]
        else:
            return self.node_builder(children)


class PropagatePositions:
    def __init__(self, node_builder, node_filter=None):
        self.node_builder = node_builder
        self.node_filter = node_filter

    def __call__(self, children):
        res = self.node_builder(children)

        if isinstance(res, Tree):
            ##

            ##

            ##

            ##


            res_meta = res.meta

            first_meta = self._pp_get_meta(children)
            if first_meta is not None:
                if not hasattr(res_meta, "line"):
                    ##

                    res_meta.line = getattr(
                        first_meta, "container_line", first_meta.line
                    )
                    res_meta.column = getattr(
                        first_meta, "container_column", first_meta.column
                    )
                    res_meta.start_pos = getattr(
                        first_meta, "container_start_pos", first_meta.start_pos
                    )
                    res_meta.empty = False

                res_meta.container_line = getattr(
                    first_meta, "container_line", first_meta.line
                )
                res_meta.container_column = getattr(
                    first_meta, "container_column", first_meta.column
                )
                res_meta.container_start_pos = getattr(
                    first_meta, "container_start_pos", first_meta.start_pos
                )

            last_meta = self._pp_get_meta(reversed(children))
            if last_meta is not None:
                if not hasattr(res_meta, "end_line"):
                    res_meta.end_line = getattr(
                        last_meta, "container_end_line", last_meta.end_line
                    )
                    res_meta.end_column = getattr(
                        last_meta, "container_end_column", last_meta.end_column
                    )
                    res_meta.end_pos = getattr(
                        last_meta, "container_end_pos", last_meta.end_pos
                    )
                    res_meta.empty = False

                res_meta.container_end_line = getattr(
                    last_meta, "container_end_line", last_meta.end_line
                )
                res_meta.container_end_column = getattr(
                    last_meta, "container_end_column", last_meta.end_column
                )
                res_meta.container_end_pos = getattr(
                    last_meta, "container_end_pos", last_meta.end_pos
                )

        return res

    def _pp_get_meta(self, children):
        for c in children:
            if self.node_filter is not None and not self.node_filter(c):
                continue
            if isinstance(c, Tree):
                if not c.meta.empty:
                    return c.meta
            elif isinstance(c, Token):
                return c
            elif hasattr(c, "__lark_meta__"):
                return c.__lark_meta__()


def make_propagate_positions(option):
    if callable(option):
        return partial(PropagatePositions, node_filter=option)
    elif option is True:
        return PropagatePositions
    elif option is False:
        return None

    raise ConfigurationError("Invalid option for propagate_positions: %r" % option)


class ChildFilter:
    def __init__(self, to_include, append_none, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include
        self.append_none = append_none

    def __call__(self, children):
        filtered = []

        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                filtered += children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR(ChildFilter):
    #--

    def __call__(self, children):
        filtered = []
        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR_NoPlaceholders(ChildFilter):
    #--

    def __init__(self, to_include, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include

    def __call__(self, children):
        filtered = []
        for i, to_expand in self.to_include:
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])
        return self.node_builder(filtered)


def _should_expand(sym):
    return not sym.is_term and sym.name.startswith("_")


def maybe_create_child_filter(
    expansion, keep_all_tokens, ambiguous, _empty_indices: List[bool]
):
    ##

    if _empty_indices:
        assert _empty_indices.count(False) == len(expansion)
        s = "".join(str(int(b)) for b in _empty_indices)
        empty_indices = [len(ones) for ones in s.split("0")]
        assert len(empty_indices) == len(expansion) + 1, (empty_indices, len(expansion))
    else:
        empty_indices = [0] * (len(expansion) + 1)

    to_include = []
    nones_to_add = 0
    for i, sym in enumerate(expansion):
        nones_to_add += empty_indices[i]
        if keep_all_tokens or not (sym.is_term and sym.filter_out):
            to_include.append((i, _should_expand(sym), nones_to_add))
            nones_to_add = 0

    nones_to_add += empty_indices[len(expansion)]

    if (
        _empty_indices
        or len(to_include) < len(expansion)
        or any(to_expand for i, to_expand, _ in to_include)
    ):
        if _empty_indices or ambiguous:
            return partial(
                ChildFilter if ambiguous else ChildFilterLALR, to_include, nones_to_add
            )
        else:
            ##

            return partial(
                ChildFilterLALR_NoPlaceholders, [(i, x) for i, x, _ in to_include]
            )


class AmbiguousExpander:
    #--

    def __init__(self, to_expand, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class
        self.to_expand = to_expand

    def __call__(self, children):
        def _is_ambig_tree(t):
            return hasattr(t, "data") and t.data == "_ambig"

        ##

        ##

        ##

        ##

        ambiguous = []
        for i, child in enumerate(children):
            if _is_ambig_tree(child):
                if i in self.to_expand:
                    ambiguous.append(i)

                child.expand_kids_by_data("_ambig")

        if not ambiguous:
            return self.node_builder(children)

        expand = [
            child.children if i in ambiguous else (child,)
            for i, child in enumerate(children)
        ]
        return self.tree_class(
            "_ambig", [self.node_builder(list(f)) for f in product(*expand)]
        )


def maybe_create_ambiguous_expander(tree_class, expansion, keep_all_tokens):
    to_expand = [
        i
        for i, sym in enumerate(expansion)
        if keep_all_tokens
        or ((not (sym.is_term and sym.filter_out)) and _should_expand(sym))
    ]
    if to_expand:
        return partial(AmbiguousExpander, to_expand, tree_class)


class AmbiguousIntermediateExpander:
    #--

    def __init__(self, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class

    def __call__(self, children):
        def _is_iambig_tree(child):
            return hasattr(child, "data") and child.data == "_iambig"

        def _collapse_iambig(children):
            #--

            ##

            ##

            if children and _is_iambig_tree(children[0]):
                iambig_node = children[0]
                result = []
                for grandchild in iambig_node.children:
                    collapsed = _collapse_iambig(grandchild.children)
                    if collapsed:
                        for child in collapsed:
                            child.children += children[1:]
                        result += collapsed
                    else:
                        new_tree = self.tree_class(
                            "_inter", grandchild.children + children[1:]
                        )
                        result.append(new_tree)
                return result

        collapsed = _collapse_iambig(children)
        if collapsed:
            processed_nodes = [self.node_builder(c.children) for c in collapsed]
            return self.tree_class("_ambig", processed_nodes)

        return self.node_builder(children)


def inplace_transformer(func):
    @wraps(func)
    def f(children):
        ##

        tree = Tree(func.__name__, children)
        return func(tree)

    return f


def apply_visit_wrapper(func, name, wrapper):
    if wrapper is _vargs_meta or wrapper is _vargs_meta_inline:
        raise NotImplementedError("Meta args not supported for internal transformer")

    @wraps(func)
    def f(children):
        return wrapper(func, name, children, None)

    return f


class ParseTreeBuilder:
    def __init__(
        self,
        rules,
        tree_class,
        propagate_positions=False,
        ambiguous=False,
        maybe_placeholders=False,
    ):
        self.tree_class = tree_class
        self.propagate_positions = propagate_positions
        self.ambiguous = ambiguous
        self.maybe_placeholders = maybe_placeholders

        self.rule_builders = list(self._init_builders(rules))

    def _init_builders(self, rules):
        propagate_positions = make_propagate_positions(self.propagate_positions)

        for rule in rules:
            options = rule.options
            keep_all_tokens = options.keep_all_tokens
            expand_single_child = options.expand1

            wrapper_chain = list(
                filter(
                    None,
                    [
                        (expand_single_child and not rule.alias) and ExpandSingleChild,
                        maybe_create_child_filter(
                            rule.expansion,
                            keep_all_tokens,
                            self.ambiguous,
                            options.empty_indices if self.maybe_placeholders else None,
                        ),
                        propagate_positions,
                        self.ambiguous
                        and maybe_create_ambiguous_expander(
                            self.tree_class, rule.expansion, keep_all_tokens
                        ),
                        self.ambiguous
                        and partial(AmbiguousIntermediateExpander, self.tree_class),
                    ],
                )
            )

            yield rule, wrapper_chain

    def create_callback(self, transformer=None):
        callbacks = {}

        default_handler = getattr(transformer, "__default__", None)
        if default_handler:

            def default_callback(data, children):
                return default_handler(data, children, None)

        else:
            default_callback = self.tree_class

        for rule, wrapper_chain in self.rule_builders:
            user_callback_name = (
                rule.alias or rule.options.template_source or rule.origin.name
            )
            try:
                f = getattr(transformer, user_callback_name)
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    f = apply_visit_wrapper(f, user_callback_name, wrapper)
                elif isinstance(transformer, Transformer_InPlace):
                    f = inplace_transformer(f)
            except AttributeError:
                f = partial(default_callback, user_callback_name)

            for w in wrapper_chain:
                f = w(f)

            if rule in callbacks:
                raise GrammarError("Rule '%s' already exists" % (rule,))

            callbacks[rule] = f

        return callbacks





class Action:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def __repr__(self):
        return str(self)


Shift = Action("Shift")
Reduce = Action("Reduce")

StateT = TypeVar("StateT")


class ParseTableBase(Generic[StateT]):
    states: Dict[StateT, Dict[str, Tuple]]
    start_states: Dict[str, StateT]
    end_states: Dict[str, StateT]

    def __init__(self, states, start_states, end_states):
        self.states = states
        self.start_states = start_states
        self.end_states = end_states

    def serialize(self, memo):
        tokens = Enumerator()

        states = {
            state: {
                tokens.get(token): (
                    (1, arg.serialize(memo)) if action is Reduce else (0, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in self.states.items()
        }

        return {
            "tokens": tokens.reversed(),
            "states": states,
            "start_states": self.start_states,
            "end_states": self.end_states,
        }

    @classmethod
    def deserialize(cls, data, memo):
        tokens = data["tokens"]
        states = {
            state: {
                tokens[token]: (
                    (Reduce, Rule.deserialize(arg, memo))
                    if action == 1
                    else (Shift, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in data["states"].items()
        }
        return cls(states, data["start_states"], data["end_states"])


class ParseTable(ParseTableBase["State"]):
    #--

    pass


class IntParseTable(ParseTableBase[int]):
    #--

    @classmethod
    def from_ParseTable(cls, parse_table: ParseTable):
        enum = list(parse_table.states)
        state_to_idx: Dict["State", int] = {s: i for i, s in enumerate(enum)}
        int_states = {}

        for s, la in parse_table.states.items():
            la = {
                k: (v[0], state_to_idx[v[1]]) if v[0] is Shift else v
                for k, v in la.items()
            }
            int_states[state_to_idx[s]] = la

        start_states = {
            start: state_to_idx[s] for start, s in parse_table.start_states.items()
        }
        end_states = {
            start: state_to_idx[s] for start, s in parse_table.end_states.items()
        }
        return cls(int_states, start_states, end_states)





class ParseConf(Generic[StateT]):
    __slots__ = (
        "parse_table",
        "callbacks",
        "start",
        "start_state",
        "end_state",
        "states",
    )

    parse_table: ParseTableBase[StateT]
    callbacks: ParserCallbacks
    start: str

    start_state: StateT
    end_state: StateT
    states: Dict[StateT, Dict[str, tuple]]

    def __init__(
        self,
        parse_table: ParseTableBase[StateT],
        callbacks: ParserCallbacks,
        start: str,
    ):
        self.parse_table = parse_table

        self.start_state = self.parse_table.start_states[start]
        self.end_state = self.parse_table.end_states[start]
        self.states = self.parse_table.states

        self.callbacks = callbacks
        self.start = start


class ParserState(Generic[StateT]):
    __slots__ = "parse_conf", "lexer", "state_stack", "value_stack"

    parse_conf: ParseConf[StateT]
    lexer: LexerThread
    state_stack: List[StateT]
    value_stack: list

    def __init__(
        self,
        parse_conf: ParseConf[StateT],
        lexer: LexerThread,
        state_stack=None,
        value_stack=None,
    ):
        self.parse_conf = parse_conf
        self.lexer = lexer
        self.state_stack = state_stack or [self.parse_conf.start_state]
        self.value_stack = value_stack or []

    @property
    def position(self) -> StateT:
        return self.state_stack[-1]

    ##

    def __eq__(self, other) -> bool:
        if not isinstance(other, ParserState):
            return NotImplemented
        return (
            len(self.state_stack) == len(other.state_stack)
            and self.position == other.position
        )

    def __copy__(self):
        return type(self)(
            self.parse_conf,
            self.lexer,  ##

            copy(self.state_stack),
            deepcopy(self.value_stack),
        )

    def copy(self) -> "ParserState[StateT]":
        return copy(self)

    def feed_token(self, token: Token, is_end=False) -> Any:
        state_stack = self.state_stack
        value_stack = self.value_stack
        states = self.parse_conf.states
        end_state = self.parse_conf.end_state
        callbacks = self.parse_conf.callbacks

        while True:
            state = state_stack[-1]
            try:
                action, arg = states[state][token.type]
            except KeyError:
                expected = {s for s in states[state].keys() if s.isupper()}
                raise UnexpectedToken(
                    token, expected, state=self, interactive_parser=None
                )

            assert arg != end_state

            if action is Shift:
                ##

                assert not is_end
                state_stack.append(arg)
                value_stack.append(
                    token
                    if token.type not in callbacks
                    else callbacks[token.type](token)
                )
                return
            else:
                ##

                rule = arg
                size = len(rule.expansion)
                if size:
                    s = value_stack[-size:]
                    del state_stack[-size:]
                    del value_stack[-size:]
                else:
                    s = []

                value = callbacks[rule](s) if callbacks else s

                _action, new_state = states[state_stack[-1]][rule.origin.name]
                assert _action is Shift
                state_stack.append(new_state)
                value_stack.append(value)

                if is_end and state_stack[-1] == end_state:
                    return value_stack[-1]





class LALR_Parser(Serialize):
    def __init__(
        self, parser_conf: ParserConf, debug: bool = False, strict: bool = False
    ):
        analysis = LALR_Analyzer(parser_conf, debug=debug, strict=strict)
        analysis.compute_lalr()
        callbacks = parser_conf.callbacks

        self._parse_table = analysis.parse_table
        self.parser_conf = parser_conf
        self.parser = _Parser(analysis.parse_table, callbacks, debug)

    @classmethod
    def deserialize(cls, data, memo, callbacks, debug=False):
        inst = cls.__new__(cls)
        inst._parse_table = IntParseTable.deserialize(data, memo)
        inst.parser = _Parser(inst._parse_table, callbacks, debug)
        return inst

    def serialize(self, memo: Any = None) -> Dict[str, Any]:
        return self._parse_table.serialize(memo)

    def parse_interactive(self, lexer: LexerThread, start: str):
        return self.parser.parse(lexer, start, start_interactive=True)

    def parse(self, lexer, start, on_error=None):
        try:
            return self.parser.parse(lexer, start)
        except UnexpectedInput as e:
            if on_error is None:
                raise

            while True:
                if isinstance(e, UnexpectedCharacters):
                    s = e.interactive_parser.lexer_thread.state
                    p = s.line_ctr.char_pos

                if not on_error(e):
                    raise e

                if isinstance(e, UnexpectedCharacters):
                    ##

                    if p == s.line_ctr.char_pos:
                        s.line_ctr.feed(s.text[p : p + 1])

                try:
                    return e.interactive_parser.resume_parse()
                except UnexpectedToken as e2:
                    if (
                        isinstance(e, UnexpectedToken)
                        and e.token.type == e2.token.type == "$END"
                        and e.interactive_parser == e2.interactive_parser
                    ):
                        ##

                        raise e2
                    e = e2
                except UnexpectedCharacters as e2:
                    e = e2


class _Parser:
    parse_table: ParseTableBase
    callbacks: ParserCallbacks
    debug: bool

    def __init__(
        self,
        parse_table: ParseTableBase,
        callbacks: ParserCallbacks,
        debug: bool = False,
    ):
        self.parse_table = parse_table
        self.callbacks = callbacks
        self.debug = debug

    def parse(
        self,
        lexer: LexerThread,
        start: str,
        value_stack=None,
        state_stack=None,
        start_interactive=False,
    ):
        parse_conf = ParseConf(self.parse_table, self.callbacks, start)
        parser_state = ParserState(parse_conf, lexer, state_stack, value_stack)
        if start_interactive:
            return InteractiveParser(self, parser_state, parser_state.lexer)
        return self.parse_from_state(parser_state)

    def parse_from_state(self, state: ParserState, last_token: Optional[Token] = None):
        #--
        try:
            token = last_token
            for token in state.lexer.lex(state):
                assert token is not None
                state.feed_token(token)

            end_token = (
                Token.new_borrow_pos("$END", "", token)
                if token
                else Token("$END", "", 0, 1, 1)
            )
            return state.feed_token(end_token, True)
        except UnexpectedInput as e:
            try:
                e.interactive_parser = InteractiveParser(self, state, state.lexer)
            except NameError:
                pass
            raise e
        except Exception as e:
            if self.debug:
                print("")
                print("STATE STACK DUMP")
                print("----------------")
                for i, s in enumerate(state.state_stack):
                    print("%d)" % i, s)
                print("")

            raise





class InteractiveParser:
    #--

    def __init__(self, parser, parser_state, lexer_thread: LexerThread):
        self.parser = parser
        self.parser_state = parser_state
        self.lexer_thread = lexer_thread
        self.result = None

    @property
    def lexer_state(self) -> LexerThread:
        warnings.warn(
            "lexer_state will be removed in subsequent releases. Use lexer_thread instead.",
            DeprecationWarning,
        )
        return self.lexer_thread

    def feed_token(self, token: Token):
        #--
        return self.parser_state.feed_token(token, token.type == "$END")

    def iter_parse(self) -> Iterator[Token]:
        #--
        for token in self.lexer_thread.lex(self.parser_state):
            yield token
            self.result = self.feed_token(token)

    def exhaust_lexer(self) -> List[Token]:
        #--
        return list(self.iter_parse())

    def feed_eof(self, last_token=None):
        #--
        eof = (
            Token.new_borrow_pos("$END", "", last_token)
            if last_token is not None
            else self.lexer_thread._Token("$END", "", 0, 1, 1)
        )
        return self.feed_token(eof)

    def __copy__(self):
        #--
        return type(self)(
            self.parser,
            copy(self.parser_state),
            copy(self.lexer_thread),
        )

    def copy(self):
        return copy(self)

    def __eq__(self, other):
        if not isinstance(other, InteractiveParser):
            return False

        return (
            self.parser_state == other.parser_state
            and self.lexer_thread == other.lexer_thread
        )

    def as_immutable(self):
        #--
        p = copy(self)
        return ImmutableInteractiveParser(p.parser, p.parser_state, p.lexer_thread)

    def pretty(self):
        #--
        out = ["Parser choices:"]
        for k, v in self.choices().items():
            out.append("\t- %s -> %r" % (k, v))
        out.append("stack size: %s" % len(self.parser_state.state_stack))
        return "\n".join(out)

    def choices(self):
        #--
        return self.parser_state.parse_conf.parse_table.states[
            self.parser_state.position
        ]

    def accepts(self):
        #--
        accepts = set()
        conf_no_callbacks = copy(self.parser_state.parse_conf)
        ##

        ##

        conf_no_callbacks.callbacks = {}
        for t in self.choices():
            if t.isupper():  ##

                new_cursor = copy(self)
                new_cursor.parser_state.parse_conf = conf_no_callbacks
                try:
                    new_cursor.feed_token(self.lexer_thread._Token(t, ""))
                except UnexpectedToken:
                    pass
                else:
                    accepts.add(t)
        return accepts

    def resume_parse(self):
        #--
        return self.parser.parse_from_state(
            self.parser_state, last_token=self.lexer_thread.state.last_token
        )


class ImmutableInteractiveParser(InteractiveParser):
    #--

    result = None

    def __hash__(self):
        return hash((self.parser_state, self.lexer_thread))

    def feed_token(self, token):
        c = copy(self)
        c.result = InteractiveParser.feed_token(c, token)
        return c

    def exhaust_lexer(self):
        #--
        cursor = self.as_mutable()
        cursor.exhaust_lexer()
        return cursor.as_immutable()

    def as_mutable(self):
        #--
        p = copy(self)
        return InteractiveParser(p.parser, p.parser_state, p.lexer_thread)





def _wrap_lexer(lexer_class):
    future_interface = getattr(lexer_class, "__future_interface__", False)
    if future_interface:
        return lexer_class
    else:

        class CustomLexerWrapper(Lexer):
            def __init__(self, lexer_conf):
                self.lexer = lexer_class(lexer_conf)

            def lex(self, lexer_state, parser_state):
                return self.lexer.lex(lexer_state.text)

        return CustomLexerWrapper


def _deserialize_parsing_frontend(data, memo, lexer_conf, callbacks, options):
    parser_conf = ParserConf.deserialize(data["parser_conf"], memo)
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    parser = cls.deserialize(data["parser"], memo, callbacks, options.debug)
    parser_conf.callbacks = callbacks
    return ParsingFrontend(lexer_conf, parser_conf, options, parser=parser)


_parser_creators: "Dict[str, Callable[[LexerConf, Any, Any], Any]]" = {}


class ParsingFrontend(Serialize):
    __serialize_fields__ = "lexer_conf", "parser_conf", "parser"

    lexer_conf: LexerConf
    parser_conf: ParserConf
    options: Any

    def __init__(
        self, lexer_conf: LexerConf, parser_conf: ParserConf, options, parser=None
    ):
        self.parser_conf = parser_conf
        self.lexer_conf = lexer_conf
        self.options = options

        ##

        if parser:  ##

            self.parser = parser
        else:
            create_parser = _parser_creators.get(parser_conf.parser_type)
            assert (
                create_parser is not None
            ), "{} is not supported in standalone mode".format(parser_conf.parser_type)
            self.parser = create_parser(lexer_conf, parser_conf, options)

        ##

        lexer_type = lexer_conf.lexer_type
        self.skip_lexer = False
        if lexer_type in ("dynamic", "dynamic_complete"):
            assert lexer_conf.postlex is None
            self.skip_lexer = True
            return

        if isinstance(lexer_type, type):
            assert issubclass(lexer_type, Lexer)
            self.lexer = _wrap_lexer(lexer_type)(lexer_conf)
        elif isinstance(lexer_type, str):
            create_lexer = {
                "basic": create_basic_lexer,
                "contextual": create_contextual_lexer,
            }[lexer_type]
            self.lexer = create_lexer(
                lexer_conf, self.parser, lexer_conf.postlex, options
            )
        else:
            raise TypeError("Bad value for lexer_type: {lexer_type}")

        if lexer_conf.postlex:
            self.lexer = PostLexConnector(self.lexer, lexer_conf.postlex)

    def _verify_start(self, start=None):
        if start is None:
            start_decls = self.parser_conf.start
            if len(start_decls) > 1:
                raise ConfigurationError(
                    "Lark initialized with more than 1 possible start rule. Must specify which start rule to parse",
                    start_decls,
                )
            (start,) = start_decls
        elif start not in self.parser_conf.start:
            raise ConfigurationError(
                "Unknown start rule %s. Must be one of %r"
                % (start, self.parser_conf.start)
            )
        return start

    def _make_lexer_thread(self, text: str) -> Union[str, LexerThread]:
        cls = (self.options and self.options._plugins.get("LexerThread")) or LexerThread
        return text if self.skip_lexer else cls.from_text(self.lexer, text)

    def parse(self, text: str, start=None, on_error=None):
        chosen_start = self._verify_start(start)
        kw = {} if on_error is None else {"on_error": on_error}
        stream = self._make_lexer_thread(text)
        return self.parser.parse(stream, chosen_start, **kw)

    def parse_interactive(self, text: Optional[str] = None, start=None):
        ##

        ##

        chosen_start = self._verify_start(start)
        if self.parser_conf.parser_type != "lalr":
            raise ConfigurationError(
                "parse_interactive() currently only works with parser='lalr' "
            )
        stream = self._make_lexer_thread(text)  ##

        return self.parser.parse_interactive(stream, chosen_start)


def _validate_frontend_args(parser, lexer) -> None:
    assert_config(parser, ("lalr", "earley", "cyk"))
    if not isinstance(lexer, type):  ##

        expected = {
            "lalr": ("basic", "contextual"),
            "earley": ("basic", "dynamic", "dynamic_complete"),
            "cyk": ("basic",),
        }[parser]
        assert_config(
            lexer,
            expected,
            "Parser %r does not support lexer %%r, expected one of %%s" % parser,
        )


def _get_lexer_callbacks(transformer, terminals):
    result = {}
    for terminal in terminals:
        callback = getattr(transformer, terminal.name, None)
        if callback is not None:
            result[terminal.name] = callback
    return result


class PostLexConnector:
    def __init__(self, lexer, postlexer):
        self.lexer = lexer
        self.postlexer = postlexer

    def lex(self, lexer_state, parser_state):
        i = self.lexer.lex(lexer_state, parser_state)
        return self.postlexer.process(i)


def create_basic_lexer(lexer_conf, parser, postlex, options) -> BasicLexer:
    cls = (options and options._plugins.get("BasicLexer")) or BasicLexer
    return cls(lexer_conf)


def create_contextual_lexer(
    lexer_conf: LexerConf, parser, postlex, options
) -> ContextualLexer:
    cls = (options and options._plugins.get("ContextualLexer")) or ContextualLexer
    parse_table: ParseTableBase[int] = parser._parse_table
    states: Dict[int, Collection[str]] = {
        idx: list(t.keys()) for idx, t in parse_table.states.items()
    }
    always_accept: Collection[str] = postlex.always_accept if postlex else ()
    return cls(lexer_conf, states, always_accept=always_accept)


def create_lalr_parser(
    lexer_conf: LexerConf, parser_conf: ParserConf, options=None
) -> LALR_Parser:
    debug = options.debug if options else False
    strict = options.strict if options else False
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    return cls(parser_conf, debug=debug, strict=strict)


_parser_creators["lalr"] = create_lalr_parser




class PostLex(ABC):
    @abstractmethod
    def process(self, stream: Iterator[Token]) -> Iterator[Token]:
        return stream

    always_accept: Iterable[str] = ()


class LarkOptions(Serialize):
    #--

    start: List[str]
    debug: bool
    strict: bool
    transformer: "Optional[Transformer]"
    propagate_positions: Union[bool, str]
    maybe_placeholders: bool
    cache: Union[bool, str]
    regex: bool
    g_regex_flags: int
    keep_all_tokens: bool
    tree_class: Optional[Callable[[str, List], Any]]
    parser: _ParserArgType
    lexer: _LexerArgType
    ambiguity: 'Literal["auto", "resolve", "explicit", "forest"]'
    postlex: Optional[PostLex]
    priority: 'Optional[Literal["auto", "normal", "invert"]]'
    lexer_callbacks: Dict[str, Callable[[Token], Token]]
    use_bytes: bool
    ordered_sets: bool
    edit_terminals: Optional[Callable[[TerminalDef], TerminalDef]]
    import_paths: "List[Union[str, Callable[[Union[None, str, PackageResource], str], Tuple[str, str]]]]"
    source_path: Optional[str]

    OPTIONS_DOC = r"""
    **===  General Options  ===**

    start
            The start symbol. Either a string, or a list of strings for multiple possible starts (Default: "start")
    debug
            Display debug information and extra warnings. Use only when debugging (Default: ``False``)
            When used with Earley, it generates a forest graph as "sppf.png", if 'dot' is installed.
    strict
            Throw an exception on any potential ambiguity, including shift/reduce conflicts, and regex collisions.
    transformer
            Applies the transformer to every parse tree (equivalent to applying it after the parse, but faster)
    propagate_positions
            Propagates positional attributes into the 'meta' attribute of all tree branches.
            Sets attributes: (line, column, end_line, end_column, start_pos, end_pos,
                              container_line, container_column, container_end_line, container_end_column)
            Accepts ``False``, ``True``, or a callable, which will filter which nodes to ignore when propagating.
    maybe_placeholders
            When ``True``, the ``[]`` operator returns ``None`` when not matched.
            When ``False``,  ``[]`` behaves like the ``?`` operator, and returns no value at all.
            (default= ``True``)
    cache
            Cache the results of the Lark grammar analysis, for x2 to x3 faster loading. LALR only for now.

            - When ``False``, does nothing (default)
            - When ``True``, caches to a temporary file in the local directory
            - When given a string, caches to the path pointed by the string
    regex
            When True, uses the ``regex`` module instead of the stdlib ``re``.
    g_regex_flags
            Flags that are applied to all terminals (both regex and strings)
    keep_all_tokens
            Prevent the tree builder from automagically removing "punctuation" tokens (Default: ``False``)
    tree_class
            Lark will produce trees comprised of instances of this class instead of the default ``lark.Tree``.

    **=== Algorithm Options ===**

    parser
            Decides which parser engine to use. Accepts "earley" or "lalr". (Default: "earley").
            (there is also a "cyk" option for legacy)
    lexer
            Decides whether or not to use a lexer stage

            - "auto" (default): Choose for me based on the parser
            - "basic": Use a basic lexer
            - "contextual": Stronger lexer (only works with parser="lalr")
            - "dynamic": Flexible and powerful (only with parser="earley")
            - "dynamic_complete": Same as dynamic, but tries *every* variation of tokenizing possible.
    ambiguity
            Decides how to handle ambiguity in the parse. Only relevant if parser="earley"

            - "resolve": The parser will automatically choose the simplest derivation
              (it chooses consistently: greedy for tokens, non-greedy for rules)
            - "explicit": The parser will return all derivations wrapped in "_ambig" tree nodes (i.e. a forest).
            - "forest": The parser will return the root of the shared packed parse forest.

    **=== Misc. / Domain Specific Options ===**

    postlex
            Lexer post-processing (Default: ``None``) Only works with the basic and contextual lexers.
    priority
            How priorities should be evaluated - "auto", ``None``, "normal", "invert" (Default: "auto")
    lexer_callbacks
            Dictionary of callbacks for the lexer. May alter tokens during lexing. Use with caution.
    use_bytes
            Accept an input of type ``bytes`` instead of ``str``.
    ordered_sets
            Should Earley use ordered-sets to achieve stable output (~10% slower than regular sets. Default: True)
    edit_terminals
            A callback for editing the terminals before parse.
    import_paths
            A List of either paths or loader functions to specify from where grammars are imported
    source_path
            Override the source of from where the grammar was loaded. Useful for relative imports and unconventional grammar loading
    **=== End of Options ===**
    """
    if __doc__:
        __doc__ += OPTIONS_DOC

    ##

    ##

    ##

    ##

    ##

    ##

    _defaults: Dict[str, Any] = {
        "debug": False,
        "strict": False,
        "keep_all_tokens": False,
        "tree_class": None,
        "cache": False,
        "postlex": None,
        "parser": "earley",
        "lexer": "auto",
        "transformer": None,
        "start": "start",
        "priority": "auto",
        "ambiguity": "auto",
        "regex": False,
        "propagate_positions": False,
        "lexer_callbacks": {},
        "maybe_placeholders": True,
        "edit_terminals": None,
        "g_regex_flags": 0,
        "use_bytes": False,
        "ordered_sets": True,
        "import_paths": [],
        "source_path": None,
        "_plugins": {},
    }

    def __init__(self, options_dict: Dict[str, Any]) -> None:
        o = dict(options_dict)

        options = {}
        for name, default in self._defaults.items():
            if name in o:
                value = o.pop(name)
                if isinstance(default, bool) and name not in (
                    "cache",
                    "use_bytes",
                    "propagate_positions",
                ):
                    value = bool(value)
            else:
                value = default

            options[name] = value

        if isinstance(options["start"], str):
            options["start"] = [options["start"]]

        self.__dict__["options"] = options

        assert_config(self.parser, ("earley", "lalr", "cyk", None))

        if self.parser == "earley" and self.transformer:
            raise ConfigurationError(
                "Cannot specify an embedded transformer when using the Earley algorithm. "
                "Please use your transformer on the resulting parse tree, or use a different algorithm (i.e. LALR)"
            )

        if o:
            raise ConfigurationError("Unknown options: %s" % o.keys())

    def __getattr__(self, name: str) -> Any:
        try:
            return self.__dict__["options"][name]
        except KeyError as e:
            raise AttributeError(e)

    def __setattr__(self, name: str, value: str) -> None:
        assert_config(
            name, self.options.keys(), "%r isn't a valid option. Expected one of: %s"
        )
        self.options[name] = value

    def serialize(self, memo=None) -> Dict[str, Any]:
        return self.options

    @classmethod
    def deserialize(
        cls, data: Dict[str, Any], memo: Dict[int, Union[TerminalDef, Rule]]
    ) -> "LarkOptions":
        return cls(data)


##

##

_LOAD_ALLOWED_OPTIONS = {
    "postlex",
    "transformer",
    "lexer_callbacks",
    "use_bytes",
    "debug",
    "g_regex_flags",
    "regex",
    "propagate_positions",
    "tree_class",
    "_plugins",
}

_VALID_PRIORITY_OPTIONS = ("auto", "normal", "invert", None)
_VALID_AMBIGUITY_OPTIONS = ("auto", "resolve", "explicit", "forest")


_T = TypeVar("_T", bound="Lark")


class Lark(Serialize):
    #--

    source_path: str
    source_grammar: str
    grammar: "Grammar"
    options: LarkOptions
    lexer: Lexer
    parser: "ParsingFrontend"
    terminals: Collection[TerminalDef]

    def __init__(self, grammar: "Union[Grammar, str, IO[str]]", **options) -> None:
        self.options = LarkOptions(options)
        re_module: types.ModuleType

        ##

        use_regex = self.options.regex
        if use_regex:
            if _has_regex:
                re_module = regex
            else:
                raise ImportError(
                    "`regex` module must be installed if calling `Lark(regex=True)`."
                )
        else:
            re_module = re

        ##

        if self.options.source_path is None:
            try:
                self.source_path = grammar.name  ##

            except AttributeError:
                self.source_path = "<string>"
        else:
            self.source_path = self.options.source_path

        ##

        try:
            read = grammar.read  ##

        except AttributeError:
            pass
        else:
            grammar = read()

        cache_fn = None
        cache_sha256 = None
        if isinstance(grammar, str):
            self.source_grammar = grammar
            if self.options.use_bytes:
                if not isascii(grammar):
                    raise ConfigurationError(
                        "Grammar must be ascii only, when use_bytes=True"
                    )

            if self.options.cache:
                if self.options.parser != "lalr":
                    raise ConfigurationError(
                        "cache only works with parser='lalr' for now"
                    )

                unhashable = (
                    "transformer",
                    "postlex",
                    "lexer_callbacks",
                    "edit_terminals",
                    "_plugins",
                )
                options_str = "".join(
                    k + str(v) for k, v in options.items() if k not in unhashable
                )
                from . import __version__

                s = grammar + options_str + __version__ + str(sys.version_info[:2])
                cache_sha256 = sha256_digest(s)

                if isinstance(self.options.cache, str):
                    cache_fn = self.options.cache
                else:
                    if self.options.cache is not True:
                        raise ConfigurationError("cache argument must be bool or str")

                    try:
                        username = getpass.getuser()
                    except Exception:
                        ##

                        ##

                        ##

                        username = "unknown"

                    cache_fn = (
                        tempfile.gettempdir()
                        + "/.lark_cache_%s_%s_%s_%s.tmp"
                        % (username, cache_sha256, *sys.version_info[:2])
                    )

                old_options = self.options
                try:
                    with FS.open(cache_fn, "rb") as f:
                        logger.debug("Loading grammar from cache: %s", cache_fn)
                        ##

                        for name in set(options) - _LOAD_ALLOWED_OPTIONS:
                            del options[name]
                        file_sha256 = f.readline().rstrip(b"\n")
                        cached_used_files = pickle.load(f)
                        if file_sha256 == cache_sha256.encode(
                            "utf8"
                        ) and verify_used_files(cached_used_files):
                            cached_parser_data = pickle.load(f)
                            self._load(cached_parser_data, **options)
                            return
                except FileNotFoundError:
                    ##

                    pass
                except (
                    Exception
                ):  ##

                    logger.exception(
                        "Failed to load Lark from cache: %r. We will try to carry on.",
                        cache_fn,
                    )

                    ##

                    ##

                    self.options = old_options

            ##

            self.grammar, used_files = load_grammar(
                grammar,
                self.source_path,
                self.options.import_paths,
                self.options.keep_all_tokens,
            )
        else:
            assert isinstance(grammar, Grammar)
            self.grammar = grammar

        if self.options.lexer == "auto":
            if self.options.parser == "lalr":
                self.options.lexer = "contextual"
            elif self.options.parser == "earley":
                if self.options.postlex is not None:
                    logger.info(
                        "postlex can't be used with the dynamic lexer, so we use 'basic' instead. "
                        "Consider using lalr with contextual instead of earley"
                    )
                    self.options.lexer = "basic"
                else:
                    self.options.lexer = "dynamic"
            elif self.options.parser == "cyk":
                self.options.lexer = "basic"
            else:
                assert False, self.options.parser
        lexer = self.options.lexer
        if isinstance(lexer, type):
            assert issubclass(
                lexer, Lexer
            )  ##

        else:
            assert_config(lexer, ("basic", "contextual", "dynamic", "dynamic_complete"))
            if self.options.postlex is not None and "dynamic" in lexer:
                raise ConfigurationError(
                    "Can't use postlex with a dynamic lexer. Use basic or contextual instead"
                )

        if self.options.ambiguity == "auto":
            if self.options.parser == "earley":
                self.options.ambiguity = "resolve"
        else:
            assert_config(
                self.options.parser,
                ("earley", "cyk"),
                "%r doesn't support disambiguation. Use one of these parsers instead: %s",
            )

        if self.options.priority == "auto":
            self.options.priority = "normal"

        if self.options.priority not in _VALID_PRIORITY_OPTIONS:
            raise ConfigurationError(
                "invalid priority option: %r. Must be one of %r"
                % (self.options.priority, _VALID_PRIORITY_OPTIONS)
            )
        if self.options.ambiguity not in _VALID_AMBIGUITY_OPTIONS:
            raise ConfigurationError(
                "invalid ambiguity option: %r. Must be one of %r"
                % (self.options.ambiguity, _VALID_AMBIGUITY_OPTIONS)
            )

        if self.options.parser is None:
            terminals_to_keep = "*"
        elif self.options.postlex is not None:
            terminals_to_keep = set(self.options.postlex.always_accept)
        else:
            terminals_to_keep = set()

        ##

        self.terminals, self.rules, self.ignore_tokens = self.grammar.compile(
            self.options.start, terminals_to_keep
        )

        if self.options.edit_terminals:
            for t in self.terminals:
                self.options.edit_terminals(t)

        self._terminals_dict = {t.name: t for t in self.terminals}

        ##

        if self.options.priority == "invert":
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = -rule.options.priority
            for term in self.terminals:
                term.priority = -term.priority
        ##

        ##

        ##

        elif self.options.priority is None:
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = None
            for term in self.terminals:
                term.priority = 0

        ##

        self.lexer_conf = LexerConf(
            self.terminals,
            re_module,
            self.ignore_tokens,
            self.options.postlex,
            self.options.lexer_callbacks,
            self.options.g_regex_flags,
            use_bytes=self.options.use_bytes,
            strict=self.options.strict,
        )

        if self.options.parser:
            self.parser = self._build_parser()
        elif lexer:
            self.lexer = self._build_lexer()

        if cache_fn:
            logger.debug("Saving grammar to cache: %s", cache_fn)
            try:
                with FS.open(cache_fn, "wb") as f:
                    assert cache_sha256 is not None
                    f.write(cache_sha256.encode("utf8") + b"\n")
                    pickle.dump(used_files, f)
                    self.save(f, _LOAD_ALLOWED_OPTIONS)
            except IOError as e:
                logger.exception("Failed to save Lark to cache: %r.", cache_fn, e)

    if __doc__:
        __doc__ += "\n\n" + LarkOptions.OPTIONS_DOC

    __serialize_fields__ = "parser", "rules", "options"

    def _build_lexer(self, dont_ignore: bool = False) -> BasicLexer:
        lexer_conf = self.lexer_conf
        if dont_ignore:
            from copy import copy

            lexer_conf = copy(lexer_conf)
            lexer_conf.ignore = ()
        return BasicLexer(lexer_conf)

    def _prepare_callbacks(self) -> None:
        self._callbacks = {}
        ##

        if self.options.ambiguity != "forest":
            self._parse_tree_builder = ParseTreeBuilder(
                self.rules,
                self.options.tree_class or Tree,
                self.options.propagate_positions,
                self.options.parser != "lalr" and self.options.ambiguity == "explicit",
                self.options.maybe_placeholders,
            )
            self._callbacks = self._parse_tree_builder.create_callback(
                self.options.transformer
            )
        self._callbacks.update(
            _get_lexer_callbacks(self.options.transformer, self.terminals)
        )

    def _build_parser(self) -> "ParsingFrontend":
        self._prepare_callbacks()
        _validate_frontend_args(self.options.parser, self.options.lexer)
        parser_conf = ParserConf(self.rules, self._callbacks, self.options.start)
        return _construct_parsing_frontend(
            self.options.parser,
            self.options.lexer,
            self.lexer_conf,
            parser_conf,
            options=self.options,
        )

    def save(self, f, exclude_options: Collection[str] = ()) -> None:
        #--
        if self.options.parser != "lalr":
            raise NotImplementedError(
                "Lark.save() is only implemented for the LALR(1) parser."
            )
        data, m = self.memo_serialize([TerminalDef, Rule])
        if exclude_options:
            data["options"] = {
                n: v for n, v in data["options"].items() if n not in exclude_options
            }
        pickle.dump({"data": data, "memo": m}, f, protocol=pickle.HIGHEST_PROTOCOL)

    @classmethod
    def load(cls: Type[_T], f) -> _T:
        #--
        inst = cls.__new__(cls)
        return inst._load(f)

    def _deserialize_lexer_conf(
        self,
        data: Dict[str, Any],
        memo: Dict[int, Union[TerminalDef, Rule]],
        options: LarkOptions,
    ) -> LexerConf:
        lexer_conf = LexerConf.deserialize(data["lexer_conf"], memo)
        lexer_conf.callbacks = options.lexer_callbacks or {}
        lexer_conf.re_module = regex if options.regex else re
        lexer_conf.use_bytes = options.use_bytes
        lexer_conf.g_regex_flags = options.g_regex_flags
        lexer_conf.skip_validation = True
        lexer_conf.postlex = options.postlex
        return lexer_conf

    def _load(self: _T, f: Any, **kwargs) -> _T:
        if isinstance(f, dict):
            d = f
        else:
            d = pickle.load(f)
        memo_json = d["memo"]
        data = d["data"]

        assert memo_json
        memo = SerializeMemoizer.deserialize(
            memo_json, {"Rule": Rule, "TerminalDef": TerminalDef}, {}
        )
        options = dict(data["options"])
        if (set(kwargs) - _LOAD_ALLOWED_OPTIONS) & set(LarkOptions._defaults):
            raise ConfigurationError(
                "Some options are not allowed when loading a Parser: {}".format(
                    set(kwargs) - _LOAD_ALLOWED_OPTIONS
                )
            )
        options.update(kwargs)
        self.options = LarkOptions.deserialize(options, memo)
        self.rules = [Rule.deserialize(r, memo) for r in data["rules"]]
        self.source_path = "<deserialized>"
        _validate_frontend_args(self.options.parser, self.options.lexer)
        self.lexer_conf = self._deserialize_lexer_conf(
            data["parser"], memo, self.options
        )
        self.terminals = self.lexer_conf.terminals
        self._prepare_callbacks()
        self._terminals_dict = {t.name: t for t in self.terminals}
        self.parser = _deserialize_parsing_frontend(
            data["parser"],
            memo,
            self.lexer_conf,
            self._callbacks,
            self.options,  ##

        )
        return self

    @classmethod
    def _load_from_dict(cls, data, memo, **kwargs):
        inst = cls.__new__(cls)
        return inst._load({"data": data, "memo": memo}, **kwargs)

    @classmethod
    def open(
        cls: Type[_T], grammar_filename: str, rel_to: Optional[str] = None, **options
    ) -> _T:
        #--
        if rel_to:
            basepath = os.path.dirname(rel_to)
            grammar_filename = os.path.join(basepath, grammar_filename)
        with open(grammar_filename, encoding="utf8") as f:
            return cls(f, **options)

    @classmethod
    def open_from_package(
        cls: Type[_T],
        package: str,
        grammar_path: str,
        search_paths: "Sequence[str]" = [""],
        **options
    ) -> _T:
        #--
        package_loader = FromPackageLoader(package, search_paths)
        full_path, text = package_loader(None, grammar_path)
        options.setdefault("source_path", full_path)
        options.setdefault("import_paths", [])
        options["import_paths"].append(package_loader)
        return cls(text, **options)

    def __repr__(self):
        return "Lark(open(%r), parser=%r, lexer=%r, ...)" % (
            self.source_path,
            self.options.parser,
            self.options.lexer,
        )

    def lex(self, text: str, dont_ignore: bool = False) -> Iterator[Token]:
        #--
        lexer: Lexer
        if not hasattr(self, "lexer") or dont_ignore:
            lexer = self._build_lexer(dont_ignore)
        else:
            lexer = self.lexer
        lexer_thread = LexerThread.from_text(lexer, text)
        stream = lexer_thread.lex(None)
        if self.options.postlex:
            return self.options.postlex.process(stream)
        return stream

    def get_terminal(self, name: str) -> TerminalDef:
        #--
        return self._terminals_dict[name]

    def parse_interactive(
        self, text: Optional[str] = None, start: Optional[str] = None
    ) -> "InteractiveParser":
        #--
        return self.parser.parse_interactive(text, start=start)

    def parse(
        self,
        text: str,
        start: Optional[str] = None,
        on_error: "Optional[Callable[[UnexpectedInput], bool]]" = None,
    ) -> "ParseTree":
        #--
        return self.parser.parse(text, start=start, on_error=on_error)





class DedentError(LarkError):
    pass


class Indenter(PostLex, ABC):
    paren_level: int
    indent_level: List[int]

    def __init__(self) -> None:
        self.paren_level = 0
        self.indent_level = [0]
        assert self.tab_len > 0

    def handle_NL(self, token: Token) -> Iterator[Token]:
        if self.paren_level > 0:
            return

        yield token

        indent_str = token.rsplit("\n", 1)[1]  ##

        indent = indent_str.count(" ") + indent_str.count("\t") * self.tab_len

        if indent > self.indent_level[-1]:
            self.indent_level.append(indent)
            yield Token.new_borrow_pos(self.INDENT_type, indent_str, token)
        else:
            while indent < self.indent_level[-1]:
                self.indent_level.pop()
                yield Token.new_borrow_pos(self.DEDENT_type, indent_str, token)

            if indent != self.indent_level[-1]:
                raise DedentError(
                    "Unexpected dedent to column %s. Expected dedent to %s"
                    % (indent, self.indent_level[-1])
                )

    def _process(self, stream):
        for token in stream:
            if token.type == self.NL_type:
                yield from self.handle_NL(token)
            else:
                yield token

            if token.type in self.OPEN_PAREN_types:
                self.paren_level += 1
            elif token.type in self.CLOSE_PAREN_types:
                self.paren_level -= 1
                assert self.paren_level >= 0

        while len(self.indent_level) > 1:
            self.indent_level.pop()
            yield Token(self.DEDENT_type, "")

        assert self.indent_level == [0], self.indent_level

    def process(self, stream):
        self.paren_level = 0
        self.indent_level = [0]
        return self._process(stream)

    ##

    @property
    def always_accept(self):
        return (self.NL_type,)

    @property
    @abstractmethod
    def NL_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def OPEN_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def CLOSE_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def INDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def DEDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def tab_len(self) -> int:
        raise NotImplementedError()


class PythonIndenter(Indenter):
    NL_type = "_NEWLINE"
    OPEN_PAREN_types = ["LPAR", "LSQB", "LBRACE"]
    CLOSE_PAREN_types = ["RPAR", "RSQB", "RBRACE"]
    INDENT_type = "_INDENT"
    DEDENT_type = "_DEDENT"
    tab_len = 8



import pickle, zlib, base64
DATA = (
b'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117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q117q195m/fq362osaw01DlwZOxKgbdnlE78j8XONfWU/Hfvw9a9ojSvzs9XvrHoNZn8mNrFq9f/Gqs1z7J9r/B3/B2GbI2xzhG2OsM0RtjnCNkfY5gjbHGGbI2xzhG2OsM0RtjnCNkfY5gjbHGGbI2xzhG2OsM0RtjnCNkfY5gjbHGGbI2xzhG2OsM0RtjnCNkfY5gjbHGGbI2xzhG2OsM0RtjnCNkfY5gjbHGGbI2xzhG2OsM0RtjnCNkfY5gjbHGGbI2xzhG2OsM0RtjnCNkfY5gjbHGGbI2xzhG2OsM0RtjnCNkfY5gjbHGGbI2xzhG2OsM0RtjnCNkfY5gjbHGGbI2xzhG2OsM0RtjnCNkfY5gjbHGGbI2xzhG2OsM0RtjnCNkfY5gjbHGGbI2xzhG2uGbb/Z2ziF8q9Vw1/odzPxsKpQZypQZypQZypQZypQZypQZypQZypQZypQZypQZypQZypQZypQZypQZypQZypQZypQZyyPM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIM7UIE4DFmdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEGdqEG8OAf5OLKxL89Sl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klEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUklEUktFcIfk3CICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCICTCIA5jUBroDpoLVQPrYMaoPVQI9QEbYBcUDPUArmhjdAmaDO0BdoKbYO2QzugVqgN2gm1Qx3QLqgT6oK6od3QHmgvtA/qgWyQB+qFNGg/dADqgw5Ch6TU27zKDx7GBzfyg/3QAOSFjkCDkA/yQwEoCA1JxbS/tT4y/bP7H9VrEe3vrHIq/B9QkOU0G5oDhaDL0FyoBSqEwlAEikIxaAwqhkqgdqgAuh+6Aj0APQgdhSqhh6CHoUegq9CjkAfqhcahPmgF9Bj0OPQE9CQUhwagYWgC6ofqIR1qgK5BPmgSmoIaoSboKcgFNUPHoROQDRqBuiALdAw6CZ2BzkLnoPPQReg01AZdgAYhK3QKugRdh56GnoGehZ6DnodegF6EXoIS0MtQEnoFehWqgqqhGqgWKoJaIS8UgDqgTqgc6oYqpGLa96wf+H1SPsK3RzE3OmZua/ybzKfMn7j3pig/Y+vC3LH4kN4L5WMyiPMR7kJ833p77KaxQOU0P7DKojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEojCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEMjCEui+EQi+EQi+EQi+EQi+EQi+EQi+EQi+EQi+EQi+EQi+UK/R+aM3dGmzxfGPiTu/YOfONOvMZhDkzYaYJ6zMf+V7m/z/IvDBSMCGew2EmEJncwvODielHZZjP8FCDllXqi5gJhZmYmA/aUA/TWGydmH6YRibMWbRqNdK4XU1ErrROTD8uQzxBI59/qOeDrFafYyYiizIHLeoV9eiJNnUwc9BiZgKyMXPQrj7ZfKpIk8oK1Cvm6IWZm6zLHBxBKmI+eUQ9TuPH6lutyz5Owzox/fCMO7wvp5mdmBnMrMzBWWt2XbBol6wT4pEdZiZkDl80Zg6uWCdEBrMrc3BVvTIjlZl+7Mb09IU5TWPmMuYcTP75KzNymtzzPuLqT5lPYrlLmpN/AIu2Q/2xa+olc1ZDPWTlGfWKmfDkhzbE01Zupz7iySrmbMbOzMEmazYmWrSX1YGZp+aHNLRW9cfexLhGPgEUD1ZpU0dvqc+6S0KUz4OmH6xiZkTazuxDXtSn55Nc8QyU/GTG9HNipjPr29nR9ONRptMj8yE2+Twp94CVT1vzT3Qx1FG7OvrX6m/OJ01ah3oprV7K50jaLvXSb1onco9F+y11sFj9GNSBWVCY1cKMkkDrVH/+8+qT8hWA1qVe+oL6FrrV0Z+qD86YdtJ2q499RX3MLBDMXH/GW9hOP4NG26OOvqFe25sdjFaftilz8C1MKJmDSc7Mwd+qD30/c/B9dWBm9++ewmv71Je2qO/XzOHNx82YDxWamahrmYM56h/Xo/58Gcbq8yl7JnRkjnaq7+S9JO35h/28p6TdfPhPr/o7ytXH8sm6pqmXFqmX9mYOlqqD95Ktz8scLFevmGn7ERWR1IE9c7Bafen96ks3qZfMVP524q4dUB/aoF6Z+QCfmZl7PjU4gsTySG7x+q/WGbOBh9R3mO9R+tGj9KNH6UeP0o8epR89Sj96lH50b/zoWPrRsfSjY+lHn8eP/qUf/Us/+pd+9C/96F/60b/0o3/pR//Sj/6lH/1LP/qXfvQv/ehf+tG/9KN/6Uf/0o/+pR/9Sz/6l370L/3oX/rRv/Sjf+lHx9KPjqUfHUs/OpZ+dCz96Fj60aP0oyvpR1fSj66kH11JP/qQfvQh/eg8+tF59KPz6Efn0Z/r8/woI88pdSFnq9e/z57/4czZ+CvZf6HF81T2+7d49me/rsWzMvtbt3iWZn86Fs/G7Pdp8WzKXIgudSFus2bPLotnS/YnZvGczX63Fs9R8dv8avbiG4UegS5DV6FiqAUqgBqhK9ADUBN0FBqG+qET0HHIBo1AXZAFOgadhM5AZ6E26Bx0HroAXYQGISt0CjoNXZKKaf/NKhshU2iETKERMoVGyBR+IFNohEyhETKFRsgUTo0pNEKm0AiZQiNkCo2QKTRCptAImUIjZAqNkCk0QqbQCJlCI2QKjZApNEKm0AiZQiNkCuvVFBohU2iETKERMoVGyBQaIVNohEyhETKFRsgUGiFTaIRM4fTOaQ1UB62F6qF1UAO0HmqEmqANkAtqhlogN7QR2gRthrZAW6Ft0HZoB9QKtUE7oXaoA9oFdUJdUDe0G9oD7YX2QT2QDfJAvZAG7YcOQH3QQeiQ1PTueO6Dh/HBjfxgPzQAeaEj0CDkg/xQAApCQ1KxTBkud8KDyDKDyDKDyDKDyDKDyDKDyDKDyCuDyCuDyCuDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCSDyCRzGoYmoH6oHtKhBugaNAlNQY1QE/QU5IKaoePQCcgGjUBdkAU6Bp2EzkBnoXPQeegidBpqgy5Ag5AVOgVdgoLQdehp6FnoOeh56EXoJSgBvQwloVegF6BXoWegIqgcqoCqoGqoBqqFWqEOqBPqhrxQQCqm/aNVvr/Jd9RnvCZRLVEjUStRJPGORL9Eq0SbhFeiQcIn4ZfokAhIdEqUS3RJdEsEJSok9gnEtH+yyufLjSGDH0MGP4ZsewzZ9hiy7THk12PIoceQQ48hhx5D1jyG7HcM2e8Yst8xZL9jyH7HkJuOIf8cQ8Y5hjxyDHnkGPLIMWSOY8gVx5AdjiE7HEM+OIZ8cAwZ4BiyvDHkdWPI5MaQu40hdxtD7jaG3G0MudsY8rMx5GdjSMjGkGWNIa8aQ141hrxqDHnVGDKpnGZBs6E5UCFUBBVDJVApVAYthBZBldASaBlUDTmg5dAqaDW0BqqD1kL1UAO0HmqCXFAz1AJthrZC26E2qAPqhLqg3dBeqAc6APVB/dAAdAQKSk3XHWO5dP7H2Xiouvl/ZhNhqxdrVi8yiV6sS71YI3uxSvVijezFyteLla8X624vVtNerKa9WCN7sXr3Irvsza2RP7HKgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNU8qNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNgsWNMONGweJGweJGweJGweJGweJGieJGieJGieJGieJGieJGieJGieJGieJGieJGieJGieJGieJGieJGieJG4eFGUHUjVLoRKt0Ijm6EdDeCuBth241A7UagdiNQuxGM3VgK3Lnw+89W+TSsUqQwpUgXS7GslmJZLcWyWopkvBSLbClSyVKk5qVIJUuRqJcioSlFMl6KZDynd6B+yAs1QD7IDwWgIPQGtAZ6E3odeguaBc2G5kBzIQs0DyqEiqESqBQqg+ZDC6CF0CKoEloM2aEl0FJoGeSAlkMroJWQE1oFrYbqoLVQPbQOWg81Qk3QBsgFNUMtkBvaCG2CNkNboK3QNmg7tAPaCbVDu6Dd0B5oL9QD2SAP1Atp0H7oANQHHYQOQYehAegINAgNScU0i012MYZwiQ7hEh3CxTWEwDmES20IoXIIwXEIF9cQLq4hXE5DCJxDCJxDuICGcAEN4QIawqk/hJN9CKf3EE7aIZy0Qzhph3CaDuHEHMKpOIRlaQgn5hBOzCGcmENYeoZwYg5h6RnCqTiEU3EIp+IQTsUhnIpDON2GcLoN4XQbwrI0hBNsCMvSEJalISxLQzgVh7CgDGFBGcKCMoRlIqciqBgqgUqhMmghtAiqhJZAy6BqyAEth1ZBq6E1UB20FqqHGqD1UBPkgpqhFmgztBXaDrVBHVAn1AXthvZCPdABqA/qhwagI1BQKqZZEQC9CIBeBEAvAqAXAdCLAOhFAPQiAHoRAL0IgF4EQC8CoBcB0IsA6EUA9CIAehEAvQiAXgRALwKgFwHQiwDoRQD0IgB6EQC9CIBeBEAvAqAXAdCLAOhFAPQiAHoRAL0IgF4EQC8CoBcB0IsA6EUA9CIAZjXd/PIiHnoRD72Ih17EQy/ioRfx0It46EU89CIeehEPvYiHXsRDL+KhF/HQi3joRTz0Ih56EQ+9iIdexEMv4qEX8dCLeOhFPPQiHnoRD72Ih17EQy/ioRfx0It46EU89CIeehEPvYiHXsRDL+KhF/HQi3joRTz0Ih56EQ+9iIdexEMv4qEX8dCLeOhFPPQiHnoRD72IhzmNSE2Pj+Q++Br0OvQG9A70JvQW/oq1+Ctimi0Tj7NvIB7LDmcW2ORE3VVcC1dxLeQ0F7JA86BCqAgqhkqgUqgMmg+VQwughVAFtAiqhKqgxZAdWgIthZZB1ZADWg7VQLXQCmgl5IRWQauhNVAdtBaqh9ZBDdB6qBFqgjZALqgZaoHc0EZoE7QZ2gJthbZB26EdUCvUBu2E2qEOaBfUCXVB3dBuaA+0F9oH9UA2yAP1Qhq0HzoA9UEHoUPQYagfGoC80BFoEPJBfigABaEhqZj2qWwAzP8CrqM5fx3bDddzbdJZ2T+Qj2ce9Go96It70J3N6XWoEyqHuqEKaB9UBb0BVUM1UC3UD62B3oS8UAMUgPxQEHoN8kFvQe9IxbTZWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSWLKSuSVrTjYAqnvR51on7nQ7/L331br3vlr33lfr4/LuAjFtru3em4D8/NepeuuINe/3er33ZiD3LtP3dpmKx2/Ns+Xu2M+uup6viQQ1i5hWmP2Eb2b+wFX1J9W9/Wdvf9ceh/wpmP/4/NlsnrzmL9k8eWde0OaPZca7402fxeYFbf4qzavW/J3mL1/zBzXj55P/scS0ouw/LV8lvZbNP6yQDSqAhqViWrH6YtoW9U5+T+S6+pl/kPr78tVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHNVbHFEijuotjuotjuotjuotjuotjuotjuotjuotjuotjuotjuotjuotjuotjuotjuotjuotjuotjuotjuotnouJJZmYqJXa5O1gn1Wf9prEGxLVEjUStRJFEv0SayRaJd6UaJPwSjRI+CQCEh0SfonXJTolyiW6JYISFRJvSewTiGllaA6msLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLyksLykcsvL/GwAnFmAmOVBvhJRtcrLE3crFz5YrWIWGWbRkq82ZhYvM5+tli9nYlo5BseGEZ+HEZ+HEUuHEUuHEUuHET2HESGHESGHESGHEROHEduGEduGEduGEduGEduGEYeGEWuGEV2GETOGETOGETOGESWGEReGEQmGEQmGce0P49ofxtU+jCt6GNfwMK7aYVynw7hOh3GdDuM6HcZ1OoxrcRjX4jCuxWFcb8O4woZxhQ3jChvGFTaMayqnWdBsaA5UCBVBxVAJVAqVQQuhRVAltARaBlVDDmg5tApaDa2B6qC1UD3UAK2HmiAX1Ay1QJuhrdB2qA3qgDqhLmg3tBfqgQ5AfVA/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JuXDTMqHmZQPMykfZlI+zKR8mJQ9zKR8mEn5MJPyYSblw0zKh5mUDzMpH2ZSPsykfJhJ+TBZfZhJ+TCT8mEm5cNMyoeZlA8zKR9mUj7MpHyYSfkwk/JhJuXDTMqHmZQPMykfZlI+zKR8mEn5MJPyYSblw0zKh5mUDzMpH2ZSPsykfJhJ+TCT8mEm5cP0DYaZlA8zKR+uZecF0ajmeFTOqm9TvrC59p63tbPjj6O/0BygO7OI5zttpi2ymbbPZtopm2tf7trmd94V/SvVL7eYR5l+MyxI3wzLzjfDSvPNsGp8M6wN3wxrQxXbQmwPEQuxO0QixIwQs0PMCXEhREeIoyEWhzgRIhuiM8TJAN2Z6955QkLtp7qM5s8yWizLaj/xJdwOcSf1q6bL0RVoMmpFMZRAV6Gr0TQ0G81Bc1ESXYOuRUvQMrQKtaHrURqtRevRBrQJbUY3oO1oJ9qNmlA72osyaB86iA6hw+goOo5OoCzqRKfQZWgUGo3GonFoPJqAJqJJ6EoUR1PQVDQdzUAz0SyUQvPQfLQALUSL0GJ0HVqKlqMVaCVajdagdWgj2oK2om1oB9qF9qD96ADqQEfQMXQyVHdmabTkRF2ijqZoyVnms8f+KGos0QSr99C+GW3O3/OGyagt+uwHfd+O5SNf/w+qS94KulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZulRZeiVZelZZelZZelZZelZZelZZelZZelZZelZZelZZelZZelZZelZZelZZelZZukZZOlhZOlhZOlhZ+ktZ+llZ+llZ+llZOlFZOlFZel1Zel1Zel3ZWpdqZbUY1ztQ9SbOpX2reuun3qW6tAVVbxhd2oJ6n2ZQvRdV7wHVu0v1ZlC9JzXy03ubn97b/PTe5qf3Nv8+b1M/3uYn+zav97f56b1NNXmbn+Xb/Iu8zb/I27we3ubf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+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k83+k93uv9c/uzlK23tX4i90460zBXMzJXL4UuZmSuYmauTL1mf+Qfr45B1Qygn9W+zGdOwnfQ/WncZSv0ObMYns1Onrq19byy9W7dEfZPMdczMhdF/tQ7MZ5cQjWlZqX+DzfiKumWKdVCqnoPiUbsKZ2Wlfmc245tqo2GOummLvNy5zrphrrpP5nLnVOug4dlTT4wmdTDycufIq5wvWwfN6s5PrYN9OalAsFllOyYugGaue1ZZB2twmfNb1sEfqa9aax18K7MncntW6i9nMz6nPpe5vDlyY2rm6uho6yCsbpmkrrupg3nWwSeyY+Iqa2YDm3o2zVF1n8zV0WXWwUl1y4jLpEa++oEOqJsyV0Uz17Qzl0czl6dLrf/cp2LvcJnUGKu+zzn1Vf9kHRR8lyunw88IMpaoLzuvbsrsd2uyDq6qWzKXToevqho2de8/VHd6dhHVyFa3dOPiaWZr6ivWwR11kLksPnwV1WhUX/YA11OHLy4bo9TnvqXu1aSOHqp7PedC6vD1U2OcuvevqP/M8JVUY6m6aUDdffhKupGrbspSXzh8CdXIUjctwgX9ZxdTjTz1qRpcTf22dTBaff3wZVVDU3f6WfUDj1ZHP6+OmtXRR9V/efgaq9GibvpFddPwJVVjmbrpl7Ji6Ve5/WV1ME39GtRBZokjs1oxYiXC0NXX/766U+ZNWlrVTZ9UP4JXHX1afXLElnDDpz73GXWvdnX0OewOz6woZNYNhpcLjPGp00f9d/zq6AvqtoA6+it1t0XWwZfUTavUTX+r/ouZ1YTMhs/Z1sHX1b2/YR18Qx1kVhOes217tfqO/6i+d1Ad2dT3ziwaVKvHgjr4F+tgnPrbjFwZMKyDseqf3pba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ghtGwQ2j4IZRcMMouGEU3DAKbhgFN4yCG0bBDb9dcDPaC12GrkDXoOvQDegWFIduQ3egu1ACugndg65ChVARVAKVQxVQI+SFeqB+KA8qhVogHVonZRoR9ZRuldHNOeop3QewBbYa5a8aRaY6XR4O8plE6tkWgdj791IO8hlF/+Y1Hb6/pxQZpeqZyf9Vfevv+OQiY4u6zx+o+/ygn2ZkuNW3fisr9gN7gYeRr+vwwROOfnJe10G9yvRfqO/yHp9fdEjFwmb1W0u90oOZOss//+zUz8mRRSmtP4f+Qso0Dv9wXuflfQuHH53nG/5In/6qePzFBzHw7/9WwUeevQyfzbitPrFJ/bZSr7J3VH3C6FO16nfUZ6zGob1SfeJVlRcqdGKpvHgt9Q0yD8/MPy/z2xn+ATOnbObxaj3K2z8tT9Thc2/4UWEax1LfPfO9Mi/O71Q/11dz5J91+CQa+WIrw982c1ZlHnWZH3tkwmT+IZlfeeYfMPwvGvn83pEvcJL5t6m/8uHUv+k4huIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIohuIoBt8oxtIoxuAoxuAoxtkohuIoxuAoxuAoRt0oRt0oBvQoRusoxvVoegw+gRcr/BPE05+k73KSVceK7vZtovr8qNQc0+qAZKnxoNR4UGo8KDUelBoPSo0HpcaDUuNBqfGg1HhQajwoNR6UGg9KjQelxoNS40Gp8eBv6UGp8aDUeFBqPCg1HpQaD0qNB6XGg1LjQanxoNR4UGo8KDUelBoPSo0HpcaDUuNBqfGg1HhQajwoNR6UGg9KjQelxoNS40Gp8aDUeFBqPCg1HpQaD0qNB6XGg1LjQanxoNR4UGo8KDUelBoPSo0HpcaDUuNBqfGg1HhQajwo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JHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriJHriZLon/h1cMBl5mSR9CeWqqtDf+YLJ93Sd5BGqejaqejbqeDbqeDbqeDbqeFpvQV1QI9QE9UDVUB+0FmqB+iEdKoRaIS+0DiqCgtCb0DzoAXQfegiNhsZAY6FxkA0aD+VC+VABNAGaCE2CJkNToKlQMTQNmg7ZIQ2aAc2EyiAHNAuaDc2B5kKV0HxoAVQFvQTVQE6oFqqD6qEGaCH0MrQIWgy9ArkgN+SBlkBLoWZoGeSD/FAAaoOyoXaoAzKg5dAKqBNaCa2CVkPd0BqoF1ovZRq/i1BtQ6i2IS7aELFtiNg2RGwbIrYNodqG0GlDxLYhgtoQuG0I3DYEbhsCtw2h2obAbUMYtyHk2hC/bYjfNgRuGwK3DYHbhqhsQ/y2pX/lvzfyJd/0H+BLvv0/z95axWYcU3cYbsWvpsv2Y7VdR72eXrvarvNfU/cdeU1DXXiakxN7P9+uY8g6COXEXpD37fiGdcPHc2I/2m/gsdY6+FaOfCQNX0YzOlUz9s/q+zzn3Rpe1Pf0+P3v9p4e3/lq63PeueM5b9jxC9a36X3HR9v3cm31vV1J/fd4d47M3/u9XS79QV0lzSTBe3qfjZGXQl+QK6A/xAuf/+3FebPFX7QOpqBUfbBS8cFKReyDlQqcsH/wbO+Hrf0LsXfqtoZPU2OVVcDbvybP0+ETN3OeZs7Kl6zP/ENMtFh51sE0nJ3qDdqGYqpltxmfVJ/psm7Y++y0LcmSJ2nm9P9X68B8dp4Y09R9iqyDr6hbplgHpeqij0f1GbPU53qsg2+qnzxH3bRFntNWwhhzs+TJPdU6aFC3/KPKkax3PKdH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'
)
DATA = pickle.loads(zlib.decompress(base64.b64decode(DATA)))
MEMO = (
b'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'
)
MEMO = pickle.loads(zlib.decompress(base64.b64decode(MEMO)))
Shift = 0
Reduce = 1
def Lark_StandAlone(**kwargs):
  return Lark._load_from_dict(DATA, MEMO, **kwargs)
