# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_bin.ipynb.

# %% auto 0
__all__ = ['MethodRegistry', 'Argument', 'Method', 'BinMethod', 'bin', 'binr']

# %% ../nbs/01_bin.ipynb 4
from enum import Enum
from atyp import NPArray, IntQ, BoolQ
from pstr import safeattr, keymatch
from nlit import (PLOT, N, NBINS, METHOD, REVERSE, VERBOSE, ARGS)
from ston import (RegistryCollection, NameRegistry)

try: import numpy as np, pandas as pd, matplotlib.pyplot as plt
except ImportError as e: ...

# %% ../nbs/01_bin.ipynb 5
class MethodRegistry(NameRegistry):
    '''
    A custom metaclass for creating singleton method instances with a central registry.

    This registry is designed to track method instances and their arguments.
    The registry ensures that each method is a singleton based on its name.

    Attributes
    ----------
    _registry : RegistryCollection
        A collection to keep track of method instances.
    _arguments : RegistryCollection
        A collection to keep track of arguments for method instances.
    '''
    def __new__(cls, name, bases, namespace, **kwargs):
        namespace['_registry'] = RegistryCollection()
        namespace['_arguments'] = RegistryCollection()
        return super().__new__(cls, name, bases, namespace, **kwargs)
    
    def __call__(cls, name, *args, **kwargs):
        inst = super().__call__(name, *args, **kwargs)
        for arg in kwargs.get(ARGS, []): cls._arguments.register(arg)
        return inst

# %% ../nbs/01_bin.ipynb 6
class Argument(metaclass=NameRegistry):
    '''
    Represents an argument in a method definition, with its properties and associated functions.

    This class is intended to be a singleton, with the uniqueness determined by the name of the argument.

    Parameters
    ----------
    name : str
        The name of the argument.
    desc : str, optional
        A description of the argument.
    anno : str, optional
        The type annotation for the argument.
    dflt : str, optional
        The default value for the argument.
    optl : bool, optional
        Flag indicating whether the argument is optional.
    fncs : set, optional
        A set of functions that use this argument.

    Methods
    -------
    __repr__()
        Returns a string representation of the argument.
    __hash__()
        Returns a hash based on the argument's name.
    __eq__(other)
        Equality comparison, either with another `Argument` instance or a string.
    '''
    def __init__(self, name: str, desc: str = None, anno: str = None, dflt: str = None, optl: bool = True, fncs: set = set()):
        self.name = name
        self.desc = desc
        self.anno = anno
        self.dflt = dflt
        self.optl = optl
        self.fncs = fncs

    def __repr__(self): return f'{self.name}'
    def __hash__(self): return hash(self.name)
    def __eq__(self, other):
        if isinstance(other, type(self)): return self.name == other.name
        elif isinstance(other, str): return bool(same := keymatch(other, self.name))
        return NotImplemented


class Method(metaclass=MethodRegistry):
    '''
    Represents a method in the registry, with a description, associated arguments, and functions.

    This class is intended to be a singleton, with the uniqueness determined by the method's name.

    Parameters
    ----------
    name : str
        The name of the method.
    desc : str, optional
        A description of the method.
    args : list, optional
        A list of `Argument` instances associated with the method.
    fncs : str, optional
        A set of functions that use this method.

    Methods
    -------
    __eq__(other)
        Equality comparison, either with another `Method` instance or a string.
    '''
    def __init__(self, name: str, desc: str = None, args: list = list(), fncs: str = set()):
        self.name = name
        self.desc = desc
        self.args = args
        self.fncs = fncs

        for arg in args:
            setattr(self, safeattr(arg.name), arg)
        
    def __eq__(self, other):
        if isinstance(other, type(self)): return self.name == other.name
        elif isinstance(other, str): return bool(same := keymatch(other, self.name))
        return NotImplemented

# %% ../nbs/01_bin.ipynb 7
class BinMethod(Enum):
    '''
    An enumeration of binning methods with associated `Method` instances.

    This enumeration provides different strategies for binning data.

    Methods
    -------
    __eq__(__value)
        Checks equality with a given value.
    __iter__()
        Returns an iterator over the enum members.
    get(method)
        Retrieves the `Method` instance associated with the given method name.
    '''
    
    count = Method(
        'count', 'ensure bins have equal number of observations e.g. 5, 5, 5',
        [
            Argument('n', 'number of bins', int, 5, False, ),        
            Argument('labels', 'use labels for the resulting bins', list, False, True, set({pd.qcut})),
            Argument('reverse', 'whether to reverse the bins', bool, False, True),
            Argument('duplicates', 'whether to raise or drop duplicates', str, 'drop', True, set({pd.qcut})),
        ]
    )

    width = Method(
        'width', 'ensure bins are of equal width e.g. 0-10, 10-20, 20-30',
        [
            Argument('n', 'number of bins', int, 5, False, ),
            Argument('reverse', 'whether to reverse the bins', bool, False, True),
        ]

    )
    
    def __eq__(self, __value: object) -> bool: return self.value.__eq__(__value)
    def __iter__(self): return super().__iter__()
    @classmethod
    def get(cls, method: str): return cls(method).value

# %% ../nbs/01_bin.ipynb 8
def bin(arr: NPArray, nbins: IntQ = 5, method: BinMethod = BinMethod.count, reverse: BoolQ = False,  **kwargs):
    '''
    Bin the given array according to the specified method and parameters.

    Parameters
    ----------
    arr : NPArray
        The array to be binned.
    nbins : IntQ, optional
        The number of bins to create.
    method : BinMethod, optional
        The binning method to use.
    reverse : BoolQ, optional
        Whether to reverse the bin order.
    **kwargs
        Additional keyword arguments passed to the binning function.

    Returns
    -------
    np.ndarray
        An array of binned values.
    '''
    # makes sure the bin width is equal by count of elements in bin
    if method == BinMethod.count:
        kwargs.setdefault('labels', False)
        kwargs.setdefault('duplicates', 'drop')
        cats = pd.qcut(arr, nbins, **kwargs)

    # makes sure the bin width is equal by value e.g 0-10, 10-20, 20-30
    if method == BinMethod.width:
        _, edges = np.histogram(arr, bins=(nbins - 1))
        # edges = np.histogram_bin_edges(arr, bins=(nbins - 1))
        cats = np.digitize(arr, edges)

    if reverse: 
        cats = (cats - (nbins)) * -1
    return cats

# %% ../nbs/01_bin.ipynb 9
class binr:
    '''
    A class for binning numerical data using various strategies.

    This class encapsulates the functionality for binning data with the ability to plot
    and print the binned results.

    Parameters
    ----------
    nbins : int, optional
        The number of bins to create.
    method : BinMethod, optional
        The binning method to use.
    reverse : bool, optional
        Whether to reverse the bin order.
    verbose : bool, optional
        If set to True, prints the sizes of bins after binning.

    Methods
    -------
    __call__(arr, **kwargs)
        Bins the provided array and optionally plots or prints the results.
    bin(arr, nbins, method, reverse, **kwargs)
        A static method to bin the provided array.
    sizes(arr)
        A static method to get the sizes of the bins.
    print(arr)
        A static method to print the sizes of the bins.
    plot(arr, figsize, **kwargs)
        A static method to plot the binned results.
    '''
    def __init__(self, nbins: int = 5, method: BinMethod = BinMethod.width, reverse: bool = False, verbose: bool = False):
        if isinstance(method, str): method = BinMethod(method)
        if isinstance(method, BinMethod): method = method.value
        self.nbins = nbins
        self.method = method
        self.reverse = reverse
        self.verbose = verbose

    def __call__(self, arr: NPArray,  **kwargs):
        nbins = kwargs.pop(N, kwargs.pop(NBINS, self.nbins))
        method = kwargs.pop(METHOD, self.method)
        reverse = kwargs.pop(REVERSE, self.reverse)
        verbose = kwargs.pop(VERBOSE, self.verbose)
        plot = kwargs.pop(PLOT, False)

        cats = self.bin(arr, nbins, method, reverse)
        if verbose: self.print(cats)
        if plot: self.plot(cats, **kwargs)
        return cats
    
    @staticmethod
    def bin(arr: NPArray, nbins: IntQ = 5, method: BinMethod = BinMethod.count, reverse: BoolQ = False, **kwargs):
        return bin(arr, nbins, method, reverse, **kwargs)
    
    @staticmethod
    def sizes(arr: NPArray):
        cat, num = np.unique(arr, return_counts=True)
        return dict(zip(cat, num))
    
    @staticmethod
    def print(arr: NPArray):
        cat, num = np.unique(arr, return_counts=True)
        print(dict(zip(cat, num)))

    @staticmethod
    def plot(arr: NPArray, figsize: tuple = (3, 2), **kwargs):
        fig = plt.figure(figsize=figsize, **kwargs)
        cat, num = np.unique(arr, return_counts=True)
        plt.bar(cat, num, **kwargs)

   
